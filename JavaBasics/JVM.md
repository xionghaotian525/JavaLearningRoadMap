# JVM

## 目录
[toc]

## 一、个人总结
![](/Res/images/JVM知识框架.png)
![](/Res/images/JVM知识框架2.png)
![](/Res/images/JVM知识框架3.png)

### 1.1.类加载机制
![](/Res/images/JVM类加载机制.png)
1. **类加载步骤**
   1. **加载（loading）**
- 在这个阶段，JVM会通过类的全限定名来获取定义此类的二进制字节流。
- 这个过程通常由类加载器来完成，它从文件系统、网络或其他源读取.class文件，并转化为一个java.lang.Class对象。
- 对于数组类型，没有对应的字节码文件，它是由JVM在运行期动态生成的。 
   
   3. **验证（Verification）**
- 确保加载的类符合JVM规范，没有安全问题。
- 验证阶段可以分为文件格式验证、元数据验证、字节码验证和符号引用验证。
- 这一步是为了确保加载进来的字节码是良好格式化的，并且不会伤害到JVM自身的安全。
   
   4. **准备（Preparation）**
- JVM为类变量分配内存并设置类变量的默认初始值。
- 这些变量使用的内存都在方法区中进行分配。
   
   5. **解析（Resolution）**
- JVM将常量池内的符号引用替换为直接引用的过程。
- 符号引用来自于类型、方法、属性等的引用。
- 解析阶段将这些引用转化为实际的内存地址。
  
   6. **初始化（Initialization）**
- JVM负责对类进行初始化，主要包括执行类构造器`<clinit>()`方法的过程。
- `<clinit>()`方法是由编译器自动为每个类收集类变量的赋值动作和静态代码块中的语句合并而成。
- 在准备阶段完成之后，JVM会执行`<clinit>()`方法。
2. **类加载器**
   1. **启动类加载器(Bootstrap Class Loader)**
- 它是虚拟机自带的类加载器，负责加载Java的核心库（如`rt.jar`, `resources.jar`, `charsets.jar`等）。
- 启动类加载器是不由Java语言编写的，通常被认为是虚拟机的一部分。
- 它主要加载位于`<JAVA_HOME>/lib`目录或者被`-Xbootclasspath`参数指定的路径中的类。

   2. **扩展类加载器(Extension Class Loader)**
- 也称为标准扩展类加载器。
- 它负责加载JRE的扩展目录`<JAVA_HOME>/lib/ext`或者由Java系统变量`java.ext.dirs`指定位置中的JAR包。
- 它是`java.security.SecureClassLoader`的子类。
   
   3. **应用程序类加载器(Application Class Loader)**
- 这是与`ClassLoader.getSystemClassLoader()`方法返回的类加载器相对应。
- 它负责加载环境变量`CLASSPATH`或者系统属性`java.class.path`指定路径下的类库。
- 这个类加载器是用户自定义加载器的默认父加载器。

   4. **自定义加载器(User-Defined Class Loader)**
- Java允许开发者通过继承java.lang.ClassLoader类的方式自定义类加载器。
- 开发者可以重写findClass()方法来实现自己的加载逻辑。

   5. **系统类加载器（System Class Loader）**
- 这个加载器是Application Class Loader的同义词，为了区分概念上的不同，在某些上下文中单独称呼。
1. **三个重要特性**  
   1. **双亲委派机制**
![](/Res/images/JVM类加载机制-双亲委派.png) 
- 类加载器之间的一种层次关系。当一个类加载器收到加载请求时，它首先会将这个请求委派给父类加载器，一直向上委派到顶层的启动类加载器，只有当父类加载器无法完成这个加载请求时，子类加载器才会尝试自己去加载。
   
   2. **缓存机制**
- 出于性能考虑，一旦类被加载进内存中，它会被缓存起来，后面再次使用时不需要重新加载。

   3. **独立性**
- 不同的类加载器可以加载相同名称（全限定名）的类，这些类彼此不会产生冲突，因为属于不同的命名空间。
### 1.2.JVM内存模型（运行时数据区）
![](/Res/images/JVM内存.png)
![](/Res/images/JVM内存2.png)
1. **线程私有**
   1.1**程序计数器**
- 程序计数器是⼀块小的内存空间，可以看作是当前线程所执⾏的字节码的⾏号指示器。字节码解释器⼯作时通过改变这个计数器的值来选取下⼀条需要执⾏的字节码指令，分⽀、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。
- 由于Java虚拟机的多线程是由多线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器是一个内核）都只会执行一条线程中的指令，因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有⼀个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。
- 从上面的介绍中我们知道程序计数器主要有两个作用：
   - 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
   - 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。
- 注意：程序计数器是唯⼀⼀个不会出现 `OutOfMemoryError` 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。
   
   1.2 **虚拟机栈**

- 与程序计数器⼀样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java方法执行的内存模型，每次方法调用的数据都是通过栈传递的。
- Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。 （实际上，Java 虚拟机栈是由⼀个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法信息。）
- 局部变量表主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是⼀个指向对象起始地址的引⽤指针，也可能是指向⼀个代表对象的句柄或其他与此对象相关的位置）。
- Java 虚拟机栈会出现两种错误： `StackOverFlowError` 和 `OutOfMemoryError` 。
  - **StackOverFlowError** ： 若 Java 虚拟机栈的内存大小不允许动态扩展，**那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候**，就抛出`StackOverFlowError` 错误。
   - **OutOfMemoryError** ： 若 **Java 虚拟机堆中没有空闲内存，并且垃圾回收器也⽆法提供更多内存的话**。就会抛出 `OutOfMemoryError` 错误。
- Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。
   1.3 **本地方法栈**
- 和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，⽽本地⽅法栈则为虚拟机使⽤到的 Native ⽅法服务。 在 HotSpot 虚拟机中和 Java虚拟机栈合⼆为⼀。
- **本地方法被执行的时候**，在本地方法栈也会创建⼀个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。
- 方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 `StackOverFlowError` 和`OutOfMemoryError` 两种错误
2. **线程共享**
   2.1 堆
- 存放对象实例，几乎所有的对象实例都在这里分配内存
- Java堆是垃圾收集器管理的主要区域
- 从内存回收的角度看，由于现在的垃圾收集器基本都采用分代收集算法
- 从内存分配的角度看
   2.2 方法区
   
3. **直接内存**
### 1.3.执行引擎
1. **即时编译器**
2. **垃圾收集机制**
### 1.4.本地接口库
### 1.5.本地方法库
### 1.6.性能监控与调优

## 二、八股问题整理

### (1).简述一下JVM的内存模型
![](/Res/images/Java内存区域-JavaGuide.png)
JVM的内存模型定义了Java虚拟机在计算机内存中的运行方式，它涉及到JVM如何以及在哪里管理内存。主要包括以下几个运行时数据区域：
1. **程序计数器（Program Counter Register）**
每个线程都有自己的程序计数器，它存储当前线程执行的字节码的行号，或者对于Native方法的调用，计数器的值是Undefined。
2. **Java虚拟机栈（Java Virtual Machine Stacks）**
也是线程私有的，每个方法在执行的同时都会创建一个栈帧（Stack Frame），用于存储局部变量表、操作数栈、动态链接信息等。
3. **本地方法栈（Native Method Stack）**
类似于Java栈，但是为Native方法服务。它们不受Java语言规范的限制，具体实现依赖于虚拟机实现。
4. **堆（Heap）**
JVM内存的大部分区域，所有的线程共享。它用来存储对象实例以及数组。这是垃圾回收器管理的主要区域，也是Java内存管理的核心。
5. **方法区（Method Area）**
各个线程共享的内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。
6. **运行时常量池（Runtime Constant Pool）**
属于方法区的一部分，它存储编译期生成的各种字面量和符号引用，是每个类及接口的常量池的运行时表示形式。
7. **直接内存（Direct Memory）**
不是虚拟机运行时数据区的一部分，但也经常被用于NIO操作。这部分内存是JVM以外的内存，直接向系统申请的内存区域。

JVM内存模型的设计使得Java程序能够在多线程环境下安全有效地执行。每个线程都拥有自己的栈和程序计数器等，保证了执行的独立性，而堆和方法区则是线程间共享的内存资源，用于存储全局的类信息与对象。垃圾回收机制主要作用于堆内存和方法区部分，负责回收不再使用的对象以及类信息，确保内存的有效利用。
### (2).说说堆和栈的区别

**from《12万字Java面经总结》：**
栈是运行时单位，代表着逻辑，内含基本数据类型和堆中对象引用，所在区域连续，没有碎片；堆是存储单位，代表着数据，可被多个栈共享（包括成员中基本数据类型、引用和引用对象），所在区域不连续，会有碎片。
1. **功能不同**
栈内存用来存储局部变量和方法调用，而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。
1. **共享性不同**
栈内存是线程私有的。 堆内存是所有线程共有的。
1. **异常错误不同**
如果栈内存或者堆内存不足都会抛出异常。 
栈空间不足：`java.lang.StackOverFlowError`。 
堆空间不足：`java.lang.OutOfMemoryError`。
1. **空间大小**
栈的空间大小远远小于堆的。
### (3).什么时候会触发FullGC
Full GC（Full Garbage Collection）是一种全局性的垃圾收集过程，涵盖了所有的Java堆内存区域，包括年轻代（包含Eden区和Survivor区）、老年代以及元空间（或方法区，在JVM的不同版本中有不同的名称）。环境中存在多种情况可能会触发Full GC：

1. **老年代空间不足**：如果老年代（Old Generation）空间不足以分配新的对象，就会触发Full GC。而且，一些大对象或长期存活的对象会直接在老年代分配，如果对象过大导致老年代无法满足分配需求，也会触发Full GC。
2. **元空间或者方法区空间不足**：元空间存放了Java的类信息、常量、静态变量等数据。当元空间不足以分配新的类的元信息时，将会触发Full GC。
3. **显式调用**：如果在代码中显式调用了System.gc()，那么JVM就可能执行一次Full GC。
4. **初始化**：Full GC也可能在Java虚拟机执行某些初始化工作时被执行。
5. **JVM参数**：某些JVM启动参数设置也会产生Full GC，例如：对使用Serial/ParNew + CMS这类收集器组合，CMS收集器在某些情况下会转为Full GC。

值得注意的是，频繁的Full GC行为会严重影响应用服务器的性能，因为在Full GC进行期间，所有的用户线程会暂停，其中包括响应用户请求的线程。因此，在设计和优化Java应用的时候，我们总是尽量减少Full GC的发生。
### (4).什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？
Java虚拟机（JVM）是一个执行Java字节码的抽象计算引擎。它并不与任何特定的硬件架构绑定，是一种规范，各个硬件和操作系统平台都可以实现自己的JVM。这意味着编写的Java代码被编译成一种与平台无关的字节码格式，这些字节码可以在任何实现了JVM的平台上执行，无需做任何额外的适配。

Java之所以被称为“平台无关的编程语言”，主要基于以下两点：
1. **字节码：**
    - Java程序首先被编译为字节码（.class文件），这种中间状态是平台无关的。字节码是一种介于源代码和机器代码之间的代码，需要JVM来解释执行。
2. **JVM的跨平台特性：**
    - JVM是Java程序的运行环境，它有诸多不同的实现版本，这些不同的JVM版本分别为不同的操作系统（如Windows、Linux、macOS）所使用。这样，只要有相应平台的JVM实现，编译后的Java程序就可以在这些平台上运行，而无需做任何修改。

这种设计抽象了底层硬件和操作系统的细节，使得Java程序能够达到高度的可移植性。开发者只需写一次代码，就可以在任何支持JVM的设备上运行，大大减少了开发和部署应用程序的复杂度。
### (5).Java内存结构
![](/Res/images/java内存结构.png)
### (6).说说对象分配规则
对象的分配规则主要涉及到Java垃圾回收机制和JVM的内存模型。在HotSpot JVM中，对象主要在堆（Heap）上分配内存，堆内存又分为几个区域：年轻代（Young Generation）、老年代（Old Generation）和元空间（Metaspace；在Java 8之前是永久代 PermGen）。对象分配的规则通常如下：

1. **对象优先在Eden分配**：大部分情况下，对象会首先在年轻代的Eden区域分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC（也称作Young GC）。
2. **大对象直接进入老年代**：所谓大对象指需要大量连续内存空间的Java对象，例如很长的字符串或者数组。大对象会直接分配到老年代中，以避免在年轻代Eden区及两个Survivor区之间发生大量的内存复制。
3. **长期存活的对象将进入老年代**：对象在年轻代中经历了一定次数的GC后，如果还没有被回收，那么会被移到老年代中，以此减少在年轻代GC时的对象复活率。对象晋升到老年代的阈值可以通过参数`-XX:MaxTenuringThreshold`来设置。
4. **动态对象年龄判定**：为了更好地适应不同程序的内存状况，HotSpot JVM虚拟机并不是永远要求对象的年龄必须达到`MaxTenuringThreshold`才能晋升到老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到`MaxTenuringThreshold`中要求的年龄。
5. **空间分配担保**：在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于年轻代所有对象总空间，如果这个条件成立，那么Minor GC是安全的。如果不成立，则虚拟机会查看`HandlePromotionFailure`值是否允许担保失败。如果允许，那么会尝试一次Minor GC，如果不允许，或者尝试了还是失败，那么会改为进行一次Full GC。

根据不同的JVM和垃圾回收算法，对象分配的具体细节可能会有所不同。例如，使用G1垃圾收集器的JVM会有不同的对象分配策略。这些规则的目的是为了更有效地管理堆内存并最小化垃圾收集的影响。
### (7).描述一下JVM加载class文件的原理机制？
Java虚拟机（JVM）加载class文件的原理和机制是一系列的步骤，它在Java运行时环境中将Java类转换为可以执行的代码。这个过程通常分为以下几个主要步骤：
1. 加载（Loading）：
JVM通过类加载器（ClassLoader）读取二进制数据（.class文件）。
检查文件格式，确认是否为有效的编译后的Java类文件。
2. 链接（Linking）：
   - 验证（Verification）：检查加载的类或接口的正确性，确保它们遵守Java语言规范，不会危害JVM的安全。
   - 准备（Preparation）：为类变量分配内存并设置类变量的默认初始值。
   - 解析（Resolution）：将符号引用（如类、方法、属性的名字等）转换为直接引用（指向内存中的地址引用）。
3. 初始化（Initialization）：
对类变量进行默认初始化后，执行<clinit>()方法，也就是静态代码块和静态字段的赋值操作，按照类中静态语句块和变量声明的顺序执行。
4. 使用（Using）：
加载、链接和初始化完成后，JVM就可以使用这个类了，通过创建实例、调用方法等操作。
5. 卸载（Unloading）：
当某个类不再有任何引用，即不可触及时，JVM会在垃圾回收的过程中卸载类，释放内存空间。

JVM类加载机制具有一个重要特性，即"懒加载"（Lazy Loading）机制，类加载操作通常是在第一次使用时才进行。另外，为了支持Java程序的运行时扩展，除了JVM提供的默认类加载器外，用户还可以自定义类加载器来扩展类加载的逻辑。

类加载器有以下几种类型：

   - 引导类加载器（Bootstrap ClassLoader）：用原生代码实现，加载Java的核心库。
   - 扩展类加载器（Extension ClassLoader）：加载Java的扩展库。
   - 系统类加载器（System ClassLoader）：它根据Java应用的类路径（CLASSPATH）来加载Java应用的class文件。

这整个过程是Java实现平台无关性的重要机制之一，允许编写一次，到处运行（write once, run anywhere）。
### (8).说说Java对象创建过程
Java对象的创建过程涉及了几个步骤，主要是在JVM中的堆内存中分配对象空间并初始化。这些步骤大致如下：

1. 类加载检查：
在对象实例化前，JVM必须检查指定类的类型信息是否已被加载、链接和初始化过。通常情况下，这一步骤是在类加载过程中完成的，加载阶段由类加载器执行，确保加载的类的信息是JVM所认可的。
2. 分配内存：
确定类已被加载后，JVM会为新对象分配内存。对象的内存大小在类加载完成后即可完全确定，JVM为每个新对象分配的内存包括所有实例变量所需的内存和一些额外空间（如对象头和对齐填充）。
JVM堆内存可能是连续的（在一个指针的移动中完成），也可能是非连续的（在多个不连续的内存块中寻找足够大小的空间）。具体的分配规则取决于JVM使用的垃圾收集器算法。
3. 初始化零值：
内存分配后，JVM将所有成员变量设置为默认值。这个步骤确保了对象的实例变量不会返回不确定的状态。
4. 设置对象头：
JVM会在分配给对象的内存中写入数据，包括对象的类的类型信息、方法数据和垃圾收集相关的信息。这就是常说的“对象头”。
5. 执行<init>方法：
最后，JVM会调用构造函数。构造函数可能会调用其他构造函数，或者调用同类或父类的构造函数，这些都可能涉及到递归。构造函数完成的工作包括指定的初始化（例如变量赋值和逻辑），都会经过这个步骤。

综上，Java对象的创建是一个由类加载检查开始，涉及内存分配、成员默认初始化、对象头设置，最终执行构造方法初始化对象状态的过程。这个过程由JVM的堆内存管理和垃圾回收机制来支持和优化。
### (9).知道类的生命周期吗？
是的，类在Java中的生命周期涉及多个阶段，从加载开始直到被卸载结束。具体来说，类的生命周期包括以下阶段：

1. 加载（Loading）：
这是类生命周期的第一步，由类加载器负责从文件系统、网络或其他源将.class文件读入JVM内存。
2. 链接（Linking）：
加载之后，类会被链接到JVM中。链接分为验证、准备和解析三个阶段：
   - 验证（Verification）：确保被加载的类符合JVM规范，没有安全问题。
   - 准备（Preparation）：为类的静态变量分配内存，并将其初始化为默认值。
   - 解析（Resolution）：将类中的符号引用转换为直接引用。
3. 初始化（Initialization）：
一旦链接阶段结束，下一步是对类进行初始化，这包括执行静态代码块和静态字段的初始化赋值。
4. 使用（Using）：
当类被初始化后，就可以创建对象，执行方法等操作了。
5. 卸载（Unloading）：
在某些时候，当一个类不再被使用，并且没有任何对该类的实例的引用存在时，JVM会认为该类是一个可回收的对象，最终将其卸载。这通常发生在装载了该类的类加载器不再被引用的时候。

类加载器的生命周期：
JVM中类的生命周期紧密关联其类加载器的生命周期。因为类加载器可以是应用中的对象，也会被垃圾收集器回收。当类加载器被回收时，由该类加载器加载的类也会被卸载，前提
### (10).简述Java的对象结构
在Java中，每个对象的内存结构分为几个部分，主要包括对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。下面是对这些部分的简要说明：
对象头（Object Header）：
标记字段（Mark Word）：记录对象自身的运行时数据，如哈希码（HashCode）、垃圾收集信息、锁状态标志、线程持有的锁等。
类型指针（Class Metadata Address）：指向类元数据的指针，确定该对象是哪个类的实例。
在某些情况下，对象头可能还包括数组长度信息，如果对象是一个数组类型的话。
实例数据（Instance Data）：
对象真正存储的有效信息，也就是对象中的字段信息，包括该对象从父类继承的字段。
实例数据的排列顺序与字段在类中定义的顺序相关，并且可能会因为JVM的具体实现和字段的访问频率进行重排。
字段数据类型也会影响存儲结构，比如不同数据类型的字段可能会在内存中聚集在一起。
对齐填充（Padding）：
由于JVM要求对象的起始地址必须是8字节的整数倍（这个数值可能根据平台和JVM的实现有所不同），实例数据之后可能会有0到7字节的对齐填充，以确保对象的总大小为8字节的倍数。
这样的对象结构优化了内存的使用，并且简化了对象属性的访问过程。内存的对齐也有助于提高性能，因为这可能使得对象的访问更适宜当代计算机的缓存系统。
### (11).如何判断对象可以被回收？
在Java中，对象的垃圾回收主要依赖于可达性分析（Reachability Analysis）算法来判断对象是否可以被回收。以下是判断对象是否可以被回收的几个标准：
引用计数（Reference Counting）：
这是一种简单的垃圾回收算法，对象有一个与之关联的引用计数器。每当有一个引用连接到对象时，引用计数加一；当引用失效时，计数减一。任何时刻计数为零的对象便可被回收。
但是，在Java中，主要的垃圾回收器并不是基于引用计数器，因为它无法解决对象相互循环引用的问题。
可达性分析算法（Reachability Analysis）：
Java使用的是这种算法。它的基本思路是通过一系列的称为“根”（GC Roots）的对象作为起始点，从这些节点开始向下搜索，搜索所经过的路径称为“引用链”（Reference Chain）。
如果一个对象到所有的GC Roots都没有任何引用链相连（即从GC Roots到这个对象不可达），则证明此对象是不可用的。
GC Roots包括：
被栈中的局部变量所引用的对象（栈帧中的局部变量表）。
被方法区中的静态属性引用的对象。
被方法区中的常量引用的对象。
被本地方法栈中JNI（Java Native Interface）引用的对象。
其他判断回收的条件：
finalize：当对象无法到达时，垃圾收集器将调用其finalize()方法，此时对象可能被存活（如果在finalize()中该对象被引用），否则将被回收。
软引用（SoftReference）：当内存不足时，这类引用指向的对象可能被回收。
弱引用（WeakReference）：只要垃圾回收器发现了弱引用，不管当前内存空间足够与否，都会回收对象。
虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。
垃圾回收不可预知地发生，因此无法确切知道什么时候具体的对象会被回收。只能知道在进行可达性分析后，未被GC Roots引用的对象，被标记为可回收的状态。
### (12).JVM的永久代中会发生垃圾回收么？
在HotSpot JVM中，传统意义上的永久代（Permanent Generation，简称PermGen）是Java 8以前版本中存储已被加载类的信息、常量池、静态变量和即时编译器编译后的代码等的区域。由于这些类型的数据通常在应用程序的生命周期中很少进行修改，因此，在永久代中垃圾回收的频率会比年轻代和老年代要低很多。但这并不意味着永久代中不会发生垃圾回收。
确实，在永久代中可以发生垃圾回收，特别是以下几种情况：
卸载类：当类的ClassLoader被回收，该ClassLoader加载的类也会被卸载，前提是该类没有任何活跃的引用存在。
常量池整理：字符串常量池中的字符串可能会被清理，尤其是那些没有任何引用的字符串。
即时编译的代码回收：如果某段即时编译的代码长时间未被使用，或者系统处于做优化的需要，这段代码可能被视为可回收资源。
然而，从Java 8开始，永久代被元空间（Metaspace）所取代。元空间使用本地内存来存储类的元数据，其默认大小只受本地内存限制。在元空间中，与永久代相似，垃圾回收的行为主要包括类的卸载和废弃的即时编译代码的回收。由于元空间与直接内存相似，因此其大小不再由Java堆的大小直接限制，避免了永久代过小导致的OutOfMemoryError。不过，如果不加限制的话，元空间过大也会消耗过多的系统内存。
### (13).你知道哪些垃圾收集算法
垃圾收集（Garbage Collection，简称GC）算法是自动内存管理的核心，旨在识别并且回收那些不再被应用程序使用的内存。不同的垃圾收集算法有不同的特性，并且适用于不同类型和负载的应用程序。目前，常见的垃圾收集算法包括：
1. 标记-清除（Mark-Sweep）算法：
   - 标记阶段：遍历所有的GC Roots，标记所有从这些根节点开始可达的对象。
   - 清除阶段：遍历堆内存，回收所有未被标记的对象所占用的空间。
2. 复制（Copying）算法：
   - 堆内存被划分为两个大小相等的区域。每次只使用其中一个区域。
   - 当这一区域的内存用完时，将还存活的对象复制到另一区域，然后清理掉原区域的所有对象。
3. 标记-压缩（Mark-Compact）算法：
   - 在标记阶段与标记-清除算法相同。
   - 压缩阶段将所有存活的对象压缩到堆内存的一端，这样可以减少内存碎片。
4. 分代收集（Generational Collection）算法：
   - 将堆内存划分为年轻代（Young Generation）、老年代（Old Generation）和永久代（PermGen，Java 8后被元空间Metaspace取代），针对不同代使用不同的GC策略。
通常在年轻代使用复制算法，老年代使用标记-清除或标记-压缩算法。
1. 增量收集（Incremental Collection）算法：
   - 为了避免GC时的停顿，该算法将GC过程分为多个小步骤，轮流执行应用程序与GC操作。
2. 并发标记清除（Concurrent Mark-Sweep，CMS）算法：
   - 在满足实时性要求的前提下，尽量减少应用程序的停顿时间。
   - 通过并发标记和并发清除阶段减少GC时的停顿。
3. G1（Garbage-First）收集器：
   - 将堆内存划分为一个个大小相等的独立区域（Region）。
   - 通过优先收集价值最大化的区域（即包含大量垃圾的区域）来优化GC的性能，并且具有较好的暂停时间控制。
4. ZGC（Z Garbage Collector）和Shenandoah：
   - 这两种垃圾收集器的目标是减少STW（Stop-The-World，停止所有工作线程）暂停的时间。
它们通过并发的对象标记
### (14).调优命令有哪些？
垃圾收集算法是垃圾收集器决定在何时以及如何执行内存回收任务的一套策略。不同的垃圾收集器使用不同的算法，主流的垃圾收集算法包括：
标记-清除（Mark-Sweep）：
标记阶段：遍历所有的可达对象，并在本地存储里标记它们。
清除阶段：遍历堆内存，回收所有未被标记的对象。
缺点是会产生内存碎片。
复制（Copying）：
将存活的对象从当前内存区域复制到另一个区域，同时清理掉旧空间中的所有对象。
优点是简单、高效，不会产生碎片，通常用于年轻代。
标记-整理（Mark-Compact）：
在标记过程之后，不直接回收垃圾，而是将所有存活的对象移动到内存的一端，然后清除边界以外的内存。
该算法结合了标记-清除和复制算法的优点。
分代收集（Generational Collection）：
将堆分为几个区域（通常是年轻代和老年代），不同代用不同的策略来回收。年轻代使用复制算法，老年代使用标记-清除或标记-整理算法。
增量收集（Incremental Collection）：
将垃圾收集的过程分为多个小步骤，交替执行应用程序代码和垃圾收集代码，以减少应用程序停顿的时间。
并发标记清除（Concurrent Mark Sweep, CMS）：
主要用于减少应用程序停顿的垃圾收集器，它允许垃圾收集线程与应用程序线程并发执行。
G1（Garbage-First）：
将堆划分为多个（通常是2048个）小块，并且跨代回收，优先回收垃圾最多的区块。
对于垃圾收集器的调优命令来说，以下是一些常用的JVM参数，可以通过适当调整这些参数来优化性能：
-Xms：设置堆的初始大小。
-Xmx：设置堆的最大大小。
-XX:NewSize：设置年轻代的大小。
-XX:MaxNewSize：设置年轻代的最大大小。
-XX:PermSize：设置持久代（PermGen）的初始大小（仅适用于Java 8之前的版本）。
-XX:MaxPermSize：设置持久代的最大大小（仅适用于Java 8之前的版本）。
-XX:MetaspaceSize：设置元空间的初始大小（Java 8及之后的版本）。
-XX:MaxMetaspaceSize：设置元空间的最大大小（Java 8及之后的版本）。
-XX:+UseG1GC：开启G1垃圾收集器。
-XX:+UseConcMarkSweepGC：开启CMS垃圾收集器。
-XX:+UseParallelGC：开启并行收集器。
-XX:+UseParallelOldGC：开启并行老年代收集器。
-XX:+PrintGCDetails：打印详细的GC日志。
-XX:+PrintGCDateStamps：在GC日志中包括时间戳。
-XX:+PrintTenuringDistribution：打印对象晋升到老年代的详细信息。
-XX:SurvivorRatio：设置年轻代中Eden区与Survivor区的比例。
-XX:MaxTenuringThreshold：设置对象在Survivor区中复制的次数上限。
这些参数可以用来调整垃圾收集器的行为以及堆内存布局，最终目标是在减少垃圾回收导致的停顿和提高性能之间达到平衡。具体的最佳参数设置取决于应用程序的行为和需求。
### (15).常见调优工具有哪些
Java虚拟机（JVM）调优是一个复杂的过程，需要借助多种工具来收集数据并进行分析。常见的JVM调优工具包括：
**JVisualVM：**
包含在JDK中的一个多合一故障处理工具，用于检查JVM中的本地和远程应用程序。它可以监控应用程序的CPU、内存使用情况，分析堆转储，查看内存使用的变化，并进行线程分析等。
**JConsole：**
同样是JDK自带的JVM监视和管理控制台，它可以用来监控JVM的性能和资源消耗，包括线程使用、JVM内存消耗、类加载和JVM内部的其他数据。
**Java Flight Recorder (JFR) & Java Mission Control (JMC)**：
一组用于收集和分析来自Java应用程序和JVM本身的详细运行时信息的工具。Java Mission Control与Java Flight Recorder一起使用，以提供对JVM性能和其他详细数据的深入分析。
**GC日志分析工具：**
用于分析和可视化垃圾收集日志数据，这类工具包括 GCViewer, GCEasy, HPJmeter 和 IBM Pattern Modeling and Analysis Tool for Java Garbage Collector (PMAT)。
**MAT (Memory Analyzer Tool)**：
Eclipse开发的内存分析工具，用于分析Java堆内存，查找内存泄漏以及查看内存消耗的对象。
**VisualGC：**
可视化工具，用于监控HotSpot JVM的垃圾收集器和类加载器指标。
**YourKit Java Profiler：**
一个全功能的商业性能分析工具，提供了强大的CPU和内存分析功能，包括内存泄漏检测，CPU和内存热点分析，以及广泛的监测和可扩展性。
**JProfiler：**
另一个商业JVM分析工具，具有丰富的监视和性能分析功能来帮助开发者
### (16).Minor GC与Full GC分别在什么时候发生？
Minor GC和Full GC是Java垃圾收集过程中的两种不同类型的垃圾收集事件，它们发生的时机不同，影响的区域也不同：
Minor GC发生在年轻代（Young Generation）的内存满时。在Java堆内存管理中，年轻代主要包括了Eden区和两个Survivor区（通常被称为S0和S1）。当应用程序创建新对象时，这些对象首先被分配到Eden区。当Eden区满了，就会触发一次Minor GC，此过程通常包括：
标记可达对象。
清除不可达对象，并将可达对象移动到一个Survivor区。
对象在Survivor区之间来回复制，每次复制时年龄增加，当达到一定年龄阈值后，移动到老年代。
Full GC涉及整个Java堆内存，包括年轻代、老年代（Old Generation）以及方法区（如果使用了永久代或元空间的话）。Full GC发生的情况包括但不限于：
老年代空间不足：年轻代中的对象年龄增长到一定程度会被晋升到老年代，如果老年代空间不足以容纳这些新晋升的对象时，便会触发Full GC。
方法区空间不足：当方法区（或元空间）填满时，也会触发Full GC来释放空间。
System.gc()被调用：System类的gc()方法被调用时，会建议JVM执行Full GC，但是具体是否执行取决于JVM的策略和垃圾收集器的实现。
JVM内部的GC策略：由于JVM的内部机制，有时即使老年代未满，也可能触发Full GC。例如，为大对象分配空间时，或者JVM在某些收集器上执行了内部的GC策略决定执行Full GC。
Minor GC通常频繁且速度较快，因为只是清理年轻代的内存。相反，Full GC比较少发生但是耗时长得多，因为需要检查整个堆内存，并且在Full GC期间，JVM中的几乎所有线程都会暂停，所以有时也称为"Stop-the-World"事件。
### (17).你知道哪些JVM性能调优参数？（简单版回答）
当然，以下是一些基本的JVM性能调优参数：
-Xmx: 设置JVM最大堆大小。
-Xms: 设置JVM起始堆大小。
-Xmn: 设定年轻代大小。
-XX:PermSize: 设置永久代（Java 8之前）的初始大小。
-XX:MaxPermSize: 设置永久代的最大大小（Java 8之前）。
-XX:MetaspaceSize: 设置元空间的初始大小（Java 8及以后）。
-XX:MaxMetaspaceSize: 设置元空间的最大大小（Java 8及以后）。
-XX:+UseG1GC: 开启G1垃圾收集器。
-XX:+UseConcMarkSweepGC: 使用CMS垃圾收集器。
-XX:+UseParallelGC: 开启并行垃圾收集器。
-XX:+UseParallelOldGC: 使用并行老年代垃圾收集器。
-XX:+PrintGCDetails: 打印GC详情日志。
-XX:+PrintGCDateStamps: 打印GC的时间戳。
-XX:SurvivorRatio: 设置Eden区与Survivor区的容量比例。
-XX:NewRatio: 设置年轻代（包括Eden和两个Survivor区）与老年代的比例。
-XX:MaxTenuringThreshold: 设置对象在年轻代的最大晋升年龄。
-XX:+UseStringDeduplication: 开启Java 8u20及以后版本的String去重节省空间的特性。
根据需求和具体情况选择和调整这些参数，以优化JVM性能。
### (18).对象一定分配在堆中吗？有没有了解逃逸分析技术？
在Java中，对象通常是分配在堆内存中的，这是因为堆内存是由JVM在运行时动态分配和回收的一块内存区域，用于存放Java程序中创建的对象实例。堆内存的对象可以被程序中的任何线程访问。
然而，并非所有的对象都一定分配在堆上。通过JVM的逃逸分析技术，可能会发生不将对象分配到堆上的情况。逃逸分析是一个编译时优化策略，它分析数据的动态作用域来判断对象的分配存储。如果一个对象在方法中被创建，并且它的引用没有逃逸出这个方法，这个对象就可能被分配在栈上，这种技术叫做栈上分配。
栈上分配有几个好处：
提高内存分配的效率，栈上分配速度远快于堆上分配。
减少垃圾收集器的负担，栈上的对象可以随着方法结束而自然消亡，不需要GC介入。
逃逸分析还可以用于其他优化，比如同步消除（如果锁对象没有逃逸，那么锁操作可以消除）和标量替换（把一个对象拆散分配到多个独立的局部变量中）。
要开启逃逸分析，可以使用JVM参数-XX:+DoEscapeAnalysis，同时它默认是开启的。这是一个高级优化特性，通常会伴随JIT编译器在运行时动态作出优化决策。
### (19).虚拟机为什么使用元空间替换了永久代？
JVM在Java 8中引入了元空间（Metaspace），以取代原来的永久代（PermGen，Permanent Generation）。这个变化是基于几个原因：
内存管理简化：永久代是一个固定大小的内存区域，必须在JVM启动时指定其大小。不仅如此，开发者还需要预测其应用所需的最大元数据量，以避免OOM（OutOfMemoryError）错误。元空间利用本地内存（即操作系统的内存），从而可以动态调整大小，简化了内存管理。
性能稳定：永久代的固定大小会在很多场景下引发问题。如果分配不足，会发生永久代快速填满导致的频繁Full GC，从而影响性能。通过使用本地内存，元空间可以根据应用需求自动扩展，减少了因永久代过小而频繁进行Full GC的情况，增强了性能稳定性。
垃圾收集的改进：早期版本的JVM在进行GC时需要同时考虑永久代和堆内存，增加了垃圾收集的复杂性。将类元数据放到本地内存的元空间，使得永久代不再需要垃圾收集，从而简化了垃圾收集器的工作。
避免内存泄漏：由于永久代的大小是固定的，一些随着应用运行逐渐加载的类会持续占用这部分区域。如果类加载器无法被垃圾收集，它加载的类和所占用的内存也不会被回收，从而可能导致内存泄露。有了元空间，只要类加载器没有引用，它加载的类以及类元数据都可以被垃圾收集器回收。
和操作系统的兼容性：使用元空间能够使JVM的内存管理更为自然地与操作系统的内存管理模型相集成，有助于JVM在不同平台上的移植和优化。
因此，使用元空间替换永久代是为了优化内存管理，减少Full GC的频率，以及提高JVM垃圾收集的效率和性能稳定性。
### (20).什么是Stop The World ?  什么是OopMap？什么是安全点？
**Stop The World（STW）**指的是垃圾收集器在执行垃圾收集(GC)时，会暂停应用程序中的所有线程。在这段时间内，除了垃圾收集线程之外，没有任何线程可以执行，以保证在内存回收过程中对象引用关系不发生变化，从而安全地进行垃圾回收。STW事件的发生是GC的一个阶段，这个阶段对于几乎所有的GC算法和JVM实现都是必需的，但是GC算法的设计目标之一就是尽可能缩短STW的时间。
OopMap（Object-Oriented Programming Map）是一种数据结构，它在JVM中用于记录对象内存布局中的哪些部分是引用（即，Object-Oriented Pointers，OOPs）。在进行垃圾收集时，GC需要知道栈和寄存器中哪些位置是引用，这样才能识别所有的活动对象。OopMap由JIT编译器在编译时刻生成，确保在垃圾收集时能够迅速准确地找到这些引用。
**安全点（Safepoint）**是程序执行中的特定位置，JVM只会在这些位置停顿所有线程来进行某些特定的操作，比如垃圾回收。安全点是应用程序执行路径上的一点，这个点上可以认为所有的内存都是一致的，各个线程的状态都可以被安全地检查和修改。线程不能随意停止，它必须到达一个安全点才能停止。这主要是因为在安全点外，OopMap信息可能不准确，故而不能安全地执行垃圾收集。安全点的通常位置包括方法返回、循环的迭代之后、以及方法调用之前。
### (21).说一下JVM 的主要组成部分及其作用？
JVM（Java虚拟机）是运行Java字节码的抽象机器。它主要包含以下几个组件，每个部分都有其特定功能：
类加载器（Class Loaders）：负责加载class文件，class文件在文件系统上或网络上都可以找到。类加载器在JVM中扮演着把类文件（编译后的Java代码）加载到内存中、并形成JVM可以利用的Java类型的角色。
运行时数据区（Runtime Data Areas）：当JVM启动时，它会创建一个运行时数据区，其中包括：
程序计数器（Program Counter Register）：每个线程都有一个程序计数器，是线程私有的，它记录了线程当前的执行地址。
Java栈（Java Stack）：也是线程私有的，它的生命周期和线程相同，用于存储方法的局部变量、操作数栈和方法调用。
本地方法栈（Native Method Stack）：专门用于处理本地方法的调用。
堆（Heap）：所有线程共享的内存区域，它存放对象实例和数组。
方法区（Method Area）：同样是线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量等数据。
执行引擎（Execution Engine）：用于执行类文件中的指令。在执行引擎中，虚拟机指令根据它们被调用的次数和它们自己的复杂性，可以被解释执行（直接执行字节码）、JIT编译执行（将热点代码编译成优化的机器码）或者通过AOT编译（Ahead-of-Time编译，将字节码静态编译为机器码）执行。
本地库接口（Native Interface）：JVM通过本地库接口与本地库通信。这是一个桥梁，为JVM提供扩展性，使其可以调用其他编程语言编写的库。
垃圾回收器（Garbage Collectors）：自动管理JAVA应用程序创建的对象生命周期的系统。收集器的工作是识别内存中的无用对象，并且回收这些对象占用的内存空间，以供新对象使用。
这些组成部分共同工作，确保了Java应用程序可以在不同平台上运行，而不需要对代码进行任何修改，体现了Java的"Write Once, Run Anywhere"（WORA）的理念。
### (22).什么是指针碰撞？
指针碰撞（Pointer Bumping）是Java内存管理中的一个概念。
在对Java堆进行内存分配时，有两种常见的方式：一种是指针碰撞，另一种是空闲列表。
指针碰撞（Pointer Bumping）：如果Java堆中内存是绝对连续的，且所有用过的内存都放在一边，剩余内存放在另一边，那么分配内存时只需要动态改变一个指针即可。这个过程就像两个指针向对方移动，当两个指针相遇时，就意味着没有剩余内存了，会引发内存溢出异常，这个过程称为指针碰撞。这种方式的前提是，内存区间中存储的对象必需要连续放置，不能出现空隙。
空闲列表（Free List）：如果Java堆中的内存并不是绝对连续的，那么我们无法使用指针碰撞进行内存分配。此时，通常会选用一种称为空闲列表的方式。空闲列表通过一个列表来记录那些存储空间是可以使用的，分配的时候从列表中拿取一块可以使用的空间。
在JVM中，Serial、ParNew等垃圾收集器在新生代采用的是复制算法，所以新生代内存分配采用的是指针碰撞方式，而CMS这种以Mark-Sweep算法为基础的垃圾收集器，会产生内存碎片，内存分配时需要使用空闲列表方式。
### (23).什么是空闲列表？
空闲列表（Free List）是内存管理中的一种技术，它用来跟踪堆内存或其他内存池中空闲的内存块。每个空闲内存块都会在空闲列表中有一个对应的条目，该条目记录了内存块的位置和大小等信息。这个列表使得内存管理器能够知道哪些内存区域是未被分配的，并且可以用来存放新的数据对象。
在空闲列表内存管理策略中，当系统请求分配内存时，内存管理器会遍历空闲列表，寻找一个足够大的内存块来满足这个请求。根据特定的算法（如首次适应、最佳适应、最差适应等），管理器可能选择列表中的第一个能够满足需求的块，或者是最适合需求大小的块。
空闲列表的内存分配优点在于它能够处理各种大小的内存请求，并且可以在内存碎片之间寻找合适的位置进行数据存放。不过，频繁的分配和回收可能会导致列表中的内存块大小和顺序非常零散（内存碎片化），可能需要额外的内存整理（碎片整理）过程来优化内存分配效率。
在Java虚拟机（JVM）中，某些垃圾收集器在老年代使用空闲列表来管理内存，因为老年代中对象的生命周期较长，不适合使用复制算法，而是更倾向于使用标记-清理或者标记-整理算法来进行垃圾回收，这种情况下空闲列表可以有效管理内存分配。
### (24).什么是TLAB？
TLAB（Thread-Local Allocation Buffer）是Java虚拟机（JVM）堆内存中的一个概念，主要用于提升对象分配的性能。它是每个线程私有的内存分配区域。
在没有TLAB的情况下，所有线程分配对象都在堆的共享区域上进行，这可能导致多个线程在分配内存时互相竞争同一块内存区域，从而需要进行同步操作，这个过程称为锁竞争，它会降低性能。
为了解决这个问题，JVM采用了TLAB。使用TLAB以后，每个线程都能在各自的TLAB上分配对象，几乎完全消除了锁竞争。每个线程的TLAB只有该线程可以访问，因此在大部分情况下，对象的分配可以不需要同步，提高了分配速度。
当一个线程的TLAB空间不足时，它会分配一个新的TLAB，而旧的TLAB如果有剩余空间的话，通常来说会被废弃掉，因为一块TLAB只属于一个线程使用，不跨线程共享。这种方法虽然可能会造成一些内存的浪费，但由于它显著提高了对象分配的速度，所以这种浪费通常是值得的。
总之，TLAB是JVM中针对对象内存分配优化的一个重要技术，通过为每个线程提供专用的内存区域，它减少了线程间的竞争，提高了对象分配的性能。
### (25).对象头具体都包含哪些内容？
在Java中，对象头(Object Header)是每个对象的内存中的一部分，它包含了对象自身的运行时数据，用于存储对象自身的管理信息，比如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等。对象头的具体内容可以分为两部分：Mark Word和Class Metadata Address。
Mark Word：这是对象头的首部分，它记录对象自身的运行时数据，比如：
哈希码：存储对象的HashCode，这个HashCode可能在调用hashCode()方法时被生成。
GC分代年龄：对象在GC中的年龄信息。
锁状态标志：对象的锁信息，标记对象是否被某个线程锁定。
线程持有的锁：指向获得该对象锁的线程。
偏向线程ID：偏向锁中的线程ID，记录哪个线程拥有了偏向锁。
偏向时间戳：偏向锁的时间戳。
Class Metadata Address：接着Mark Word之后的即是指向对象类型元数据的指针，包含了对象类的元信息，比如类的全限定名、父类信息、方法信息、变量信息等。
对象头的大小在32位和64位JVM上是不同的，且取决于JVM的实现以及运行时的状态，如是否开启压缩指针(-XX:+UseCompressedOops)等选项。例如，在32位JVM上，对象头通常是8字节的Mark Word加上4字节的类型指针；而在64位JVM上，在不使用压缩指针的情况下，对象头可能是一个64位的Mark Word加上一个64位的类型指针，总共16字节。如果启用了压缩指针，那么对象头的大小可能会减少。
对象头是Java内存管理和同步锁机制的关键组成部分，JVM通过这部分信息来实现对象管理和垃圾收集等功能。
### (26).你知道哪些JVM调优参数？
### (27).说一下 JVM 有哪些垃圾回收器？
截至我的最新知识更新，Java虚拟机（JVM）提供了多种垃圾回收器（Garbage Collector，GC），每种回收器都有自己特定的应用场景和优化目标。这些回收器的设计旨在平衡不同的回收效率和暂停时间。以下是一些常见的JVM垃圾回收器：
Serial GC：这是最简单的GC实现，使用单个线程进行垃圾回收。它适合于单核处理器的系统或者小型堆。它在进行垃圾回收时会触发STW（Stop-The-World）暂停，停止所有的应用线程。
Parallel GC（也称为Throughput Collector）：这种回收器使用多个回收线程来并行地执行年轻代的垃圾回收，适用于多核服务器。它主要关注于达到一个高吞吐量。
CMS（Concurrent Mark-Sweep）GC：CMS GC主要目的是减少垃圾收集时的停顿时间。它在Mark和Sweep阶段的大部分工作都和应用线程一起并发执行。
G1 GC（Garbage-First Collector）：G1是一个面向服务器的垃圾回收器，特别适用于有大堆内存的多核CPU。G1通过将堆分割成多个区域来优化短暂的STW暂停，从而提供了一致的暂停时间模型。
ZGC（Z Garbage Collector）：ZGC是一种可伸缩的低延迟垃圾回收器，旨在减少应用程序响应时间的停顿。ZGC几乎所有的垃圾收集工作都是并发执行的。
Epsilon GC：这是一个实验性的、无操作的垃圾回收器，被称为"No-Op"或"Blackhole"回收器。它基本上不执行任何垃圾回收，主要用于测试和性能分析。
Shenandoah GC：与G1类似，Shenandoah GC也是一种并发的垃圾回收器，它的目标是尽可能减少STW暂停的时间，即使是在处理大堆或是多核CPU时。
这些回收器可以通过JVM启动参数进行配置。选择适合的垃圾回收器需要根据应用程序的特点和目标性能指标来决定，比如延迟、吞吐量、堆内存大小等因素。随着Java版本的不断更新，可能还会出现新的垃圾回收器或对现有回收器的改进。
### (28).如何选择垃圾收集器？
选择合适的垃圾收集器需要考虑多个因素，包括应用程序的特点、性能目标、硬件环境、以及可接受的系统停顿时间（STW）等。以下是选择垃圾收集器时的一些指南：
应用类型和响应要求：
对于需要更低延迟的应用程序，如实时系统或者具有交互式负载的应用程序，可以考虑使用CMS、G1或ZGC等具有并发收集阶段的收集器。
对于批处理系统、科学计算等吞吐量优先的应用，Parallel GC可能是更好的选择。
堆大小：
对于小到中等大小的堆（一般小于4GB），可以使用Serial GC或Parallel GC。
对于大型堆（超过4GB），G1 GC、ZGC或Shenandoah GC更加适合，它们针对大堆优化，能够有效减少垃圾收集时的停顿。
硬件资源：
拥有多核心CPU和大量内存的服务器级硬件通常可以受益于G1 GC、ZGC和Shenandoah GC等并发和并行垃圾收集器，因为这些收集器能够更好地利用多核心系统。
性能指标：
如果应用程序的性能指标偏向于低停顿时间（即要求快速响应），那么CMS、G1、ZGC或Shenandoah GC可能是更好的选择。
如果性能指标偏向于高吞吐量，那么Parallel GC可能更适合。
STW暂停时间的接受度：
如果应用程序能够接受较长的STW暂停时间，Serial GC或Parallel GC可以被考虑。
如果要求尽可能短的STW暂停时间，那么应该考虑G1、ZGC或Shenandoah GC。
JVM的版本和性能更新：
根据所使用的JVM版本，可用的垃圾收集器选项可能有所不同。最新版本的JVM可能引入了新的垃圾收集器或对现有收集器进行了优化。
实验及监控：
应该在生产环境的压力测试中尝试不同的垃圾收集器配置，并监控其影响，包括GC的暂停时间，吞吐量以及内存占用情况。
在实际选择过程中，可以通过设置JVM启动参数（如-XX:+UseG1GC、-XX:+UseConcMarkSweepGC、-XX:+UseParallelGC等）来指定使用特定的垃圾收集器。最好的方法是对不同的垃圾收集器进行基准测试和实地测试，以确定最适合特定应用程序的垃圾收集器。
### (29).什么是类加载器？
类加载器（Class Loader）在Java中是负责加载类的对象。在Java虚拟机（JVM）中，类加载器通过将类的.class文件中的二进制数据读入到运行时的数据区，并将这些数据转换成Class类的一个实例，从而完成类的加载过程。每个类在JVM内部都会由一个Class实例来表示。
类加载器工作过程遵循以下三个主要步骤：
加载（Loading）：查找并导入Class文件。
链接（Linking）：
验证（Verification）：确保被加载类的正确性。
准备（Preparation）：为类的静态变量分配内存，并将其初始化为默认值。
解析（Resolution）：将类中的符号引用转换成直接引用。
初始化（Initialization）：对类的静态变量进行初始化为正确的初始值。
在JVM中，有几种不同类型的类加载器：
引导类加载器（Bootstrap Class Loader）：它是虚拟机的内置类加载器，负责加载JAVA_HOME\lib目录中的类库，或者被-Xbootclasspath参数指定的路径中的类库。引导类加载器是用原生代码编写的，并不继承自java.lang.ClassLoader。
扩展类加载器（Extension Class Loader）：它负责加载JAVA_HOME\lib\ext目录中或者由java.ext.dirs系统属性指定位置中的类库。
系统（应用）类加载器（System/Application Class Loader）：这是与平时接触最多的类加载器，它根据Java应用的类路径（CLASSPATH）来加载Java类。一般调用Class.forName()方法默认使用的就是系统类加载器。
类加载器之间存在层次关系，称为双亲委派模型（Parent Delegation Model）。在这个模型中，类加载器会先代理给其父加载器尝试加载类，这样做的好处是避免类的重复加载，以及保证了Java平台核心库的类的安全性。如果父加载器无法完成加载任务，子加载器才会尝试自己去加载。
双亲委派模型不仅能够提高加载效率，由于每个类都由它的加载器及其父加载器一起协作加载，这样也可以确保Java环境中类的唯一性，以及Java核心类库的安全。用户也可以自定义类加载器，通过继承ClassLoader类并重写其findClass方法来实现。
### (30).什么是 tomcat 类加载机制？
javaguide
### (1).介绍下 Java 内存区域(运行时数据区)
### (2).说一下Java对象的创建过程
### (3).对象的访问定位有哪两种方式?
### (4).简单聊聊 JVM 内存分配与回收
### (5).说一下堆内存中对象的分配的基本策略
### (6).如何判断对象是否死亡?(两种方法)
### (7).简单的介绍一下强引用,软引用,弱引用,虚引用
### (8).如何判断一个常量是废弃常量?
### (9).如何判断一个类是无用的类?
### (10).垃圾收集有哪些算法，各自的特点？
### (11).HotSpot为什么要分为新生代和老年代？
### (12).常见的垃圾回收器有那些?
