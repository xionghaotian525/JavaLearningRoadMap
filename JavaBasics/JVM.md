# JVM

## 目录
[toc]

## 一、个人总结
![](/Res/images/JVM知识框架.png)
![](/Res/images/JVM知识框架2.png)
![](/Res/images/JVM知识框架3.png)

### 1.1.类加载机制
![](/Res/images/JVM类加载机制.png)
1. **类加载步骤**
   1. **加载（loading）**
- 在这个阶段，JVM会通过类的全限定名来获取定义此类的**二进制字节流**。
- 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
- 在内存中生成这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
- 这个过程通常由类加载器来完成，它从文件系统、网络或其他源读取.class文件，并转化为一个java.lang.Class对象。
- 对于数组类型，没有对应的字节码文件，它是由JVM在运行期动态生成的。 
   
   2. **验证（Verification）**
- 确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
- 验证阶段可以分为文件格式验证、元数据验证、字节码验证和符号引用验证。
  - **文件格式验证**
    - 验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理
    - 主要目的：保证输入的字节流能正确的解析并存储于方法区内
    - 这阶段的验证基于**二进制字节流** 
  - **元数据验证**
    - 对字节码描述的信息进行语义分析，保证其描述的信息符合Java语言规范
    - 主要目的：对类的元数据信息进行语义校检，保证不存在不符合Java语言规范的元数据信息（数据类型）
    - 这阶段的验证以及后续验证都基于**方法区**
  - **字节码验证**
    - 通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。
    - 对类的方法体进行校检分析，保证被校检的方法在运行时不会危害虚拟机的安全
  - **符号引用验证**
    - 发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三个阶段--**解析**中发生
    - 符号引用验证可以看做是对类自身以外的信息（常量池中的各种符号引用）进行匹配性校检
- 验证阶段非常重要，但不一定必要，**如果所运行的全部代码都已经被反复使用和验证过，那么在实施阶段可以使用`-Xverify:none`参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。**   
   
   3. **准备（Preparation）**
- JVM为类变量分配内存并设置类变量的默认初始值。
- 这些变量使用的内存都在方法区中进行分配。
   
   4. **解析（Resolution）**
- JVM将常量池内的符号引用替换为直接引用的过程。
- 解析动作主要针对类或**接口**、**字段**、**类方法**、**接口方法**、**方法类型**、**方法句柄**和**调用点限定符**七类符号引用。分别对应于常量池的`CONSTANT_Class_info`、`CONSTANT_Dieldref_info`、`CONSTANT_Methodref_info`、`CONSTANT_InterfaceMethodref_info`、`CONSTANT_MethodType_info`、`CONSTANT_MethodHandle_info`、`CONSTANT_InvokeDynamic_Info`。
- 解析阶段将这些引用转化为实际的内存地址。
  
   5. **初始化（Initialization）**
- JVM负责对类进行初始化，主要包括执行类构造器`<clinit>()`方法的过程。
- `<clinit>()`方法是由编译器自动为每个类收集类变量的赋值动作和静态代码块中的语句合并而成。
- 在准备阶段完成之后，JVM会执行`<clinit>()`方法。
1. **类加载器**
   1. **启动类加载器(Bootstrap Class Loader)**
- 它是虚拟机自带的类加载器，负责加载Java的核心库（如`rt.jar`, `resources.jar`, `charsets.jar`等）。
- 启动类加载器是不由Java语言编写的，通常被认为是虚拟机的一部分。
- 它主要加载位于`<JAVA_HOME>/lib`目录或者被`-Xbootclasspath`参数指定的路径中的类。

   2. **扩展类加载器(Extension Class Loader)**
- 也称为标准扩展类加载器。
- 它负责加载JRE的扩展目录`<JAVA_HOME>/lib/ext`或者由Java系统变量`java.ext.dirs`指定位置中的JAR包。
- 它是`java.security.SecureClassLoader`的子类。
   
   3. **应用程序类加载器(Application Class Loader)**
- 这是与`ClassLoader.getSystemClassLoader()`方法返回的类加载器相对应。
- 它负责加载环境变量`CLASSPATH`或者系统属性`java.class.path`指定路径下的类库。
- 这个类加载器是用户自定义加载器的默认父加载器。

   4. **自定义加载器(User-Defined Class Loader)**
- Java允许开发者通过继承java.lang.ClassLoader类的方式自定义类加载器。
- 开发者可以重写findClass()方法来实现自己的加载逻辑。

   5. **系统类加载器（System Class Loader）**
- 这个加载器是Application Class Loader的同义词，为了区分概念上的不同，在某些上下文中单独称呼。
1. **三个重要特性**  
   1. **双亲委派机制**
![](/Res/images/JVM类加载机制-双亲委派.png) 
- 类加载器之间的一种层次关系。当一个类加载器收到加载请求时，它首先会将这个请求委派给父类加载器，一直向上委派到顶层的启动类加载器，只有当父类加载器无法完成这个加载请求时，子类加载器才会尝试自己去加载。
   
   2. **缓存机制**
- 出于性能考虑，一旦类被加载进内存中，它会被缓存起来，后面再次使用时不需要重新加载。

   3. **独立性**
- 不同的类加载器可以加载相同名称（全限定名）的类，这些类彼此不会产生冲突，因为属于不同的命名空间。
### 1.2.JVM内存模型（运行时数据区）
![](/Res/images/JVM内存.png)
![](/Res/images/JVM内存2.png)
1. **线程私有**
   1.1**程序计数器（PC寄存器）**
- 作用：PC 寄存器用来**存储指向下一条指令的地址**，即将要执行的指令代码。由执行引擎读取下一条指令。
- 程序计数器是⼀块小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器⼯作时通过改变这个计数器的值来选取下⼀条需要执⾏的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。
- 由于Java虚拟机的多线程是由多线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器是一个内核）都只会执行一条线程中的指令，因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有⼀个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。
- 从上面的介绍中我们知道程序计数器主要有两个作用：
   - **字节码解释器通过改变程序计数器来依次读取指令**，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
   - 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。
- 注意：程序计数器是唯⼀⼀个不会出现 `OutOfMemoryError` 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。
   
   1.2 **虚拟机栈**

- 与程序计数器⼀样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java方法执行的内存模型，每次方法调用的数据都是通过栈传递的，每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次 Java 方法调用。
- 作用：**主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。**
- Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。 （实际上，Java 虚拟机栈是由⼀个个**栈帧**组成，而每个栈帧中都拥有：**局部变量表**、**操作数栈**、**动态链接**、**方法信息**。）
![](/Res/images/JVM虚拟机栈-栈帧.jpg)
    - **局部变量表**
    是一组变量值存储空间，主要用于存储**方法参数和定义在方法体内的局部变量**，包括编译器可知的各种 Java 虚拟机**基本数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此相关的位置）和 **returnAddress 类型**（指向了一条字节码指令的地址，已被异常表取代）。不存在线程安全问题（局部变量表建立在线程的栈上，是线程的私有数据）
    - **操作数栈**
    操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间 
    - **动态链接**
![JVM虚拟机栈-栈帧-动态链接](/Res/images/JVM虚拟机栈-栈帧-动态链接.jpg "JVM虚拟机栈-栈帧-动态链接")
      - 每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接(Dynamic Linking)。
      - **在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在 Class 文件的常量池中**。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了**将这些符号引用转换为调用方法的直接引用**
    - **方法出口**
      - 用来存放调用该方法的 PC 寄存器的值
      - 一个方法的结束有两种方式：
        1. 正常执行完成
        2. 出现未处理的异常，非正常退出
        3. 正常完成出口和异常完成出口的区别在于：**通过异常完成出口退出的不会给他的上层调用者产生任何的返回值**
      -  无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。**方法正常退出时，调用者的 PC 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址**。而通过异常退出的，返回地址是要通过异常表来确定的，栈帧中一般不会保存这部分信息。
      - 本质上，**方法的退出就是当前栈帧出栈的过程**。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。
- Java 虚拟机栈会出现两种错误： `StackOverFlowError` 和 `OutOfMemoryError` 。
  - **StackOverFlowError** ： 若 Java 虚拟机栈的内存大小不允许动态扩展，**那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候**，就抛出`StackOverFlowError` 错误。
   - **OutOfMemoryError** ： 若 **Java 虚拟机堆中没有空闲内存，并且垃圾回收器也⽆法提供更多内存的话**。就会抛出 `OutOfMemoryError` 错误。
- Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。
   1.3 **本地方法栈**
- 和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为**虚拟机执行 Java 方法** （也就是字节码）服务，⽽本地⽅法栈则为**虚拟机使用到的 Native ⽅法**服务。 在 HotSpot 虚拟机中和 Java虚拟机栈合⼆为⼀。
- **本地方法被执行的时候**，在本地方法栈也会创建⼀个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。
- 方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 `StackOverFlowError` 和`OutOfMemoryError` 两种错误。**如果线程请求分配的栈容量超过本地方法栈允许的最大容量**，Java 虚拟机将会抛出一个 `StackOverflowError` 异常。**如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈**，那么 Java虚拟机将会抛出一个`OutofMemoryError`异常
>**栈是运行时的单位，而堆是存储的单位。**
>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪。
2. **线程共享**
   2.1 **堆**
- 存放对象实例，几乎所有的对象实例都在这里分配内存
- Java堆是垃圾收集器管理的主要区域
- 从内存回收(GC)的角度看，由于现在的垃圾收集器基本都采用**分代收集算法**，所以java堆还可以细分为新生代和老年代。
![](/Res/images/JVM堆细分.png)
  - **新生代**
   是用来存放新生的对象。一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发**MinorGC** 进行垃圾回收。新生代又分为**Eden 区**、**ServivorFrom**、**ServivorTo** 三个区。
      - Eden区：
      Java 新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行一次垃圾回收。 
      - ServivorFrom
      上一次 GC 的幸存者，作为这一次 GC 的被扫描者。 
      - ServivorTo
      保存Eden区经过一次MintorGC后的幸存者。 
      - MinerGC的过程（复制-->清空-->互换）
        - eden、servivorFrom 复制到 ServivorTo，年龄+1
        - 清空 eden、servivorFrom
        - ServivorTo 和 ServivorFrom 互换
  - **老年代**
      1. 主要存放应用程序中生命周期长的内存对象。
      2. 老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。
      3. MajorGC 采用**标记清除算法**：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC 的耗时比较长，因为要扫描再回收。MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的 时候，就会抛出 `OOM(Out of Memory)`异常。 
  - 永久代
![](/Res/images/JVM堆-pdai.jpg)
![](/Res/images/JVM堆-堆的永久代-元空间.jpg)
     1. 永久代是 HotSpot 虚拟机对虚拟机规范中⽅法区的⼀种实现⽅式。
     2. 在 Java8 中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。元空间的本质和永久代类似，元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，**元空间的大小仅受本地内存限制**。类的元数据放入 native memory, 字符串池和类的静态变量放入 java 堆中，这样可以加载多少类的元数据就不再由MaxPermSize 控制, 而由系统的实际可用空间来控制。
     3. 使用永久代实现方法区容易遇到内存溢出的问题（永久代有-XX：MaxPermSize的上限） 
   
   2.2 **方法区**
- Java 虚拟机规范把方法区描述为堆的⼀个逻辑部分，它⽤于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
- hotspot中方法区的实现：通过**堆的永久代**来实现，JDK1.8方法区替换成**直接内存中的元空间**
- 运行时常量池   
运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版
本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），用于存放**编译期生成的各种字面量和符号引用**，这部分内容将在类加
载后存放到方法区的运行时常量池中。 Java 虚拟机对 Class 文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。
3. **直接内存**
- 直接内存并不是虚拟机运⾏时数据区的⼀部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使⽤。而且也可能导致 OutOfMemoryError 错误出现。
- JDK1.4 中新加⼊的 NIO(New Input/Output) 类，引⼊了⼀种基于通道（Channel） 与缓存区（Buffer） 的 I/O ⽅式，它可以直接使⽤ Native 函数库直接分配堆外内存，然后通过⼀个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引⽤进⾏操作。这样就能在⼀些场景中显著提⾼性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。
- 本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存⼤⼩以及处理器寻址空间的限制。
### 1.3.执行引擎
1. **解释器（Interpreter）**
2. **即时编译器（JIT）**
3. **垃圾收集机制（GC）**
   ![](/Res/images/JVM-GC.png)
   1. **判断一个对象是否可被回收**
      - **引用计数算法**
      给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。
      ```java
      public class ReferenceCountingGC {

         public Object instance = null;

         public static void main(String[] args) {
            ReferenceCountingGC objectA = new ReferenceCountingGC();
            ReferenceCountingGC objectB = new ReferenceCountingGC();
            objectA.instance = objectB;
            objectB.instance = objectA;
         }
      }

      ```
      - **可达性分析算法**
         ![](/Res/images/JVM-GC-判断对象是否可回收-可达性算法.png)
         通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。
         Java 虚拟机使用该算法来判断对象是否可被回收，在 Java 中 GC Roots 一般包含以下内容:
         - 虚拟机栈中引用的对象
         - 本地方法栈中引用的对象
         - 方法区中类静态属性引用的对象
         - 方法区中的常量引用的对象
      - **方法区的回收**
         因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，因此在方法区上进行回收性价比不高。主要是对常量池的回收和对类的卸载。在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载:
         - 该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。
         - 加载该类的 ClassLoader 已经被回收。
         - 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。
         - 可以通过 -Xnoclassgc 参数来控制是否对类进行卸载。
      - **finalize()**
         finalize() 类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 `try-finally` 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。自救只能进行一次，如果回收的对象之前调用了 finalize() 方法自救，后面回收时不会调用 finalize() 方法。
   1. **四种引用类型**
      - **强引用**
         1. 被强引用关联的对象不会被回收。
         2. 使用 new 一个新对象的方式来创建强引用。
         ```java
         Object obj = new Object();
         ``` 
      - **弱引用**
         1. 被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。
         2. 使用 WeakReference 类来实现弱引用。
         ```java
         Object obj = new Object();
         WeakReference<Object> wf = new WeakReference<Object>(obj);
         obj = null;
         ```  
      - **软引用**
         1. 被软引用关联的对象只有在内存不够的情况下才会被回收。
         2. 使用 SoftReference 类来创建软引用。
         ```java
         Object obj = new Object();
         SoftReference<Object> sf = new SoftReference<Object>(obj);
         obj = null;  // 使对象只被软引用关联
         ``` 
      - **虚引用**
         1. 又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。
         2. 为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。
         3. 使用 PhantomReference 来实现虚引用。
         ```java
         Object obj = new Object();
         PhantomReference<Object> pf = new PhantomReference<Object>(obj);
         obj = null;
         ``` 
   1. **垃圾收集器**：
   ![](/Res/images/GC垃圾收集器.png)
      - **Serial收集器**
      ![](/Res/images/GC-垃圾收集器-Serial.jpg) 
        1. Serial 翻译为串行，也就是说它以串行的方式执行。
        2. 它是单线程的收集器，只会使用一个线程进行垃圾收集工作。
        3. 它的优点是简单高效，对于单个 CPU 环境来说，由于没有线程交互的开销，因此拥有最高的单线程收集效率。
        4. 它是 Client 模式下的默认新生代收集器，因为在用户的桌面应用场景下，分配给虚拟机管理的内存一般来说不会很大。Serial 收集器收集几十兆甚至一两百兆的新生代停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿是可以接受的。
      - **ParNew收集器**
      ![](/Res/images/GC-垃圾收集器-ParNew.jpg) 
         1. 它是 Serial 收集器的多线程版本。
         2. 是 Server 模式下的虚拟机首选新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。
         3. 默认开启的线程数量与 CPU 数量相同，可以使用 -XX:ParallelGCThreads 参数来设置线程数。
      - **Parallel Scavenge收集器**
         1. 与 ParNew 一样是多线程收集器。
         2. 其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。
         3. 停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。
         4. 缩短停顿时间是以牺牲吞吐量和新生代空间来换取的: 新生代空间变小，垃圾回收变得频繁，导致吞吐量下降。
         5. 可以通过一个开关参数打开 GC 自适应的调节策略(GC Ergonomics)，就不需要手动指定新生代的大小(-Xmn)、Eden 和 Survivor 区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。
      - **Serial Old(MSC)收集器**
      ![](/Res/images/GC-垃圾收集器-SerialOld.jpg) 
         1. 是 Serial 收集器的老年代版本，也是给 Client 模式下的虚拟机使用。
         2. 如果用在 Server 模式下，它有两大用途:
            - 在 JDK 1.5 以及之前版本(Parallel Old 诞生以前)中与 Parallel Scavenge 收集器搭配使用。
            - 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。      
      - **Parallel old收集器**
      ![](/Res/images/GC-垃圾收集器-ParallelOld.jpg) 
         1. 是 Parallel Scavenge 收集器的老年代版本。
         2. 在**注重吞吐量**以及 **CPU 资源敏感**的场合，都可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。
      - **CMS收集器**
      ![](/Res/images/GC-垃圾收集器-CMS.jpg) 
         1. CMS(Concurrent Mark Sweep)，Mark Sweep 指的是标记 - 清除算法。
         2. 分为以下四个流程:
            - 初始标记: 仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿。
            - 并发标记: 进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要停顿。
            - 重新标记: 为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿。
            - 并发清除: 不需要停顿。
         3. 在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿。
         4. 具有以下缺点:
            - 吞吐量低: **低停顿时间是以牺牲吞吐量为代价的**，导致 CPU 利用率不够高。
            - 无法处理浮动垃圾，可能出现 `Concurrent Mode Failure`。浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果**预留的内存不够存放浮动垃圾**，就会出现 `Concurrent Mode Failure`，这时虚拟机将临时启用 Serial Old 来替代 CMS。
            - 标记 - 清除算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。
      - **G1收集器**
         1. G1(Garbage-First)，它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。
         2. 堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。
      
      ![](/Res/images/JVM堆细分.png) 
      G1 把堆划分成多个大小相等的独立区域(Region)，新生代和老年代不再物理隔离。
      ![](/Res/images/JVM-GC-垃圾收集器-G1收集器-堆划分.png)
         
         3. 通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间(这两个值是通过过去回收的经验获得)，并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。
         4. 每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。

      ![](/Res/images/GC-垃圾收集器-G1.jpg) 

         5. 如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤:
            - **初始标记**
            - **并发标记**
            - **最终标记**: 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。
            - **筛选回收**: 首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。
         6. 具备如下特点:
            - 空间整合: **整体**来看是基于“标记 - 整理”算法实现的收集器，从**局部**(两个Region之间)上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。
            - 可预测的停顿: 能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。

   2. **垃圾收集算法**：
      - **标记-清除算法**
      ![](/Res/images/GC-垃圾回收算法-标记-清除.jpg)
      将存活的对象进行标记，然后清理掉未被标记的对象。
      不足:
        1. 标记和清除过程效率都不高；
        2. 会产生大量不连续的内存碎片，导致无法给大对象分配内存。
      - **复制算法**
      ![](/Res/images/GC-垃圾回收算法-复制.jpg) 
         1. 将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。
         2. 主要不足是只使用了内存的一半。
         3. 现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。
         4. HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。
      - **标记-整理算法**
      ![](/Res/images/GC-垃圾回收算法-标记-整理.jpg) 
      让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
      - **分代收集算法**
      现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。一般将堆分为新生代和老年代。
         1. 新生代使用: 复制算法
         2. 老年代使用: 标记 - 清除 或者 标记 - 整理 算法
   3. **内存分配与回收策略**
      - **MinorGC、MajorGC、FullGC**
         JVM 在进行 GC 时，并非每次都对堆内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。
         针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大类：部分收集（Partial GC），整堆收集（Full GC）
         1. 部分收集：不是完整收集整个 Java 堆的垃圾收集。其中又分为： 
            - 新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集
            - 老年代收集（Major GC/Old GC）：只是老年代的垃圾收集 
               - 目前，只有 CMS GC 会有单独收集老年代的行为
               - 很多时候 Major GC 会和 Full GC 混合使用，需要具体分辨是老年代回收还是整堆回收
            - 混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集 
               - 目前只有 G1 GC 会有这种行为
         2. 整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾
      - **内存分配策略**
        1. 对象优先在 Eden 分配
            大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。 
        3. 大对象直接进入老年代
            - 大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。
            - 经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。
            - `-XX:PretenureSizeThreshold`，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。
        4. 长期存活的对象进入老年代
            - 为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。
            - `-XX:MaxTenuringThreshold` 用来定义年龄的阈值。
        5. 动态对象年龄判定
            - 虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果**在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半**，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。
        6. 空间分配担保
            - 在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。
            - 如果不成立的话虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。        
      - **FullGC触发条件**
         1. 调用 System.gc()
            只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。 
         3. 老年代空间不足
            - 老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。
            - 为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 `-XX:MaxTenuringThreshold` 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。
         4. 空间分配担保失败
            使用**复制算法**的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。 
         5. JDK 1.7 及以前的永久代空间不足
            - 在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。
            - 当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。
            - 为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。
         6. Concurrent Mode Failure
            执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足(可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足)，便会报 Concurrent Mode Failure 错误，并触发 Full GC。
### 1.4.本地接口库
### 1.5.本地方法库
### 1.6.性能监控与调优

## 二、八股问题整理

### (1).简述一下JVM的内存模型
![](/Res/images/Java内存区域-JavaGuide.png)
JVM的内存模型定义了Java虚拟机在计算机内存中的运行方式，它涉及到JVM如何以及在哪里管理内存。主要包括以下几个运行时数据区域：
1. **程序计数器（Program Counter Register）**
每个线程都有自己的程序计数器，它存储当前线程执行的字节码的行号，或者对于Native方法的调用，计数器的值是Undefined。
2. **Java虚拟机栈（Java Virtual Machine Stacks）**
也是线程私有的，每个方法在执行的同时都会创建一个栈帧（Stack Frame），用于存储局部变量表、操作数栈、动态链接信息等。
3. **本地方法栈（Native Method Stack）**
类似于Java栈，但是为Native方法服务。它们不受Java语言规范的限制，具体实现依赖于虚拟机实现。
4. **堆（Heap）**
JVM内存的大部分区域，所有的线程共享。它用来存储对象实例以及数组。这是垃圾回收器管理的主要区域，也是Java内存管理的核心。
5. **方法区（Method Area）**
各个线程共享的内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。
6. **运行时常量池（Runtime Constant Pool）**
属于方法区的一部分，它存储编译期生成的各种字面量和符号引用，是每个类及接口的常量池的运行时表示形式。
7. **直接内存（Direct Memory）**
不是虚拟机运行时数据区的一部分，但也经常被用于NIO操作。这部分内存是JVM以外的内存，直接向系统申请的内存区域。

JVM内存模型的设计使得Java程序能够在多线程环境下安全有效地执行。每个线程都拥有自己的栈和程序计数器等，保证了执行的独立性，而堆和方法区则是线程间共享的内存资源，用于存储全局的类信息与对象。垃圾回收机制主要作用于堆内存和方法区部分，负责回收不再使用的对象以及类信息，确保内存的有效利用。
### (2).说说堆和栈的区别

**from《12万字Java面经总结》：**
栈是运行时单位，代表着逻辑，内含基本数据类型和堆中对象引用，所在区域连续，没有碎片；堆是存储单位，代表着数据，可被多个栈共享（包括成员中基本数据类型、引用和引用对象），所在区域不连续，会有碎片。
1. **功能不同**
栈内存用来存储局部变量和方法调用，而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。
1. **共享性不同**
栈内存是线程私有的。 堆内存是所有线程共有的。
1. **异常错误不同**
如果栈内存或者堆内存不足都会抛出异常。 
栈空间不足：`java.lang.StackOverFlowError`。 
堆空间不足：`java.lang.OutOfMemoryError`。
1. **空间大小**
栈的空间大小远远小于堆的。
### (3).什么时候会触发FullGC
Full GC（Full Garbage Collection）是一种全局性的垃圾收集过程，涵盖了所有的Java堆内存区域，包括年轻代（包含Eden区和Survivor区）、老年代以及元空间（或方法区，在JVM的不同版本中有不同的名称）。环境中存在多种情况可能会触发Full GC：

1. **老年代空间不足**：如果老年代（Old Generation）空间不足以分配新的对象，就会触发Full GC。而且，一些大对象或长期存活的对象会直接在老年代分配，如果对象过大导致老年代无法满足分配需求，也会触发Full GC。
2. **元空间或者方法区空间不足**：元空间存放了Java的类信息、常量、静态变量等数据。当元空间不足以分配新的类的元信息时，将会触发Full GC。
3. **显式调用**：如果在代码中显式调用了System.gc()，那么JVM就可能执行一次Full GC。
4. **初始化**：Full GC也可能在Java虚拟机执行某些初始化工作时被执行。
5. **JVM参数**：某些JVM启动参数设置也会产生Full GC，例如：对使用Serial/ParNew + CMS这类收集器组合，CMS收集器在某些情况下会转为Full GC。

值得注意的是，频繁的Full GC行为会严重影响应用服务器的性能，因为在Full GC进行期间，所有的用户线程会暂停，其中包括响应用户请求的线程。因此，在设计和优化Java应用的时候，我们总是尽量减少Full GC的发生。
### (4).什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？
Java虚拟机（JVM）是一个执行Java字节码的抽象计算引擎。它并不与任何特定的硬件架构绑定，是一种规范，各个硬件和操作系统平台都可以实现自己的JVM。这意味着编写的Java代码被编译成一种与平台无关的字节码格式，这些字节码可以在任何实现了JVM的平台上执行，无需做任何额外的适配。

Java之所以被称为“平台无关的编程语言”，主要基于以下两点：
1. **字节码：**
    - Java程序首先被编译为字节码（.class文件），这种中间状态是平台无关的。字节码是一种介于源代码和机器代码之间的代码，需要JVM来解释执行。
2. **JVM的跨平台特性：**
    - JVM是Java程序的运行环境，它有诸多不同的实现版本，这些不同的JVM版本分别为不同的操作系统（如Windows、Linux、macOS）所使用。这样，只要有相应平台的JVM实现，编译后的Java程序就可以在这些平台上运行，而无需做任何修改。

这种设计抽象了底层硬件和操作系统的细节，使得Java程序能够达到高度的可移植性。开发者只需写一次代码，就可以在任何支持JVM的设备上运行，大大减少了开发和部署应用程序的复杂度。
### (5).Java内存结构
![](/Res/images/java内存结构.png)
### (6).说说对象分配规则
对象的分配规则主要涉及到Java垃圾回收机制和JVM的内存模型。在HotSpot JVM中，对象主要在堆（Heap）上分配内存，堆内存又分为几个区域：年轻代（Young Generation）、老年代（Old Generation）和元空间（Metaspace；在Java 8之前是永久代 PermGen）。对象分配的规则通常如下：

1. **对象优先在Eden分配**：大部分情况下，对象会首先在年轻代的Eden区域分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC（也称作Young GC）。
2. **大对象直接进入老年代**：所谓大对象指需要大量连续内存空间的Java对象，例如很长的字符串或者数组。大对象会直接分配到老年代中，以避免在年轻代Eden区及两个Survivor区之间发生大量的内存复制。
3. **长期存活的对象将进入老年代**：对象在年轻代中经历了一定次数的GC后，如果还没有被回收，那么会被移到老年代中，以此减少在年轻代GC时的对象复活率。对象晋升到老年代的阈值可以通过参数`-XX:MaxTenuringThreshold`来设置。
4. **动态对象年龄判定**：为了更好地适应不同程序的内存状况，HotSpot JVM虚拟机并不是永远要求对象的年龄必须达到`MaxTenuringThreshold`才能晋升到老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到`MaxTenuringThreshold`中要求的年龄。
5. **空间分配担保**：在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于年轻代所有对象总空间，如果这个条件成立，那么Minor GC是安全的。如果不成立，则虚拟机会查看`HandlePromotionFailure`值是否允许担保失败。如果允许，那么会尝试一次Minor GC，如果不允许，或者尝试了还是失败，那么会改为进行一次Full GC。

根据不同的JVM和垃圾回收算法，对象分配的具体细节可能会有所不同。例如，使用G1垃圾收集器的JVM会有不同的对象分配策略。这些规则的目的是为了更有效地管理堆内存并最小化垃圾收集的影响。
### (7).描述一下JVM加载class文件的原理机制？
Java虚拟机（JVM）加载class文件的原理和机制是一系列的步骤，它在Java运行时环境中将Java类转换为可以执行的代码。这个过程通常分为以下几个主要步骤：
1. 加载（Loading）：
JVM通过类加载器（ClassLoader）读取二进制数据（.class文件）。
检查文件格式，确认是否为有效的编译后的Java类文件。
2. 链接（Linking）：
   - 验证（Verification）：检查加载的类或接口的正确性，确保它们遵守Java语言规范，不会危害JVM的安全。
   - 准备（Preparation）：为类变量分配内存并设置类变量的默认初始值。
   - 解析（Resolution）：将符号引用（如类、方法、属性的名字等）转换为直接引用（指向内存中的地址引用）。
3. 初始化（Initialization）：
对类变量进行默认初始化后，执行<clinit>()方法，也就是静态代码块和静态字段的赋值操作，按照类中静态语句块和变量声明的顺序执行。
4. 使用（Using）：
加载、链接和初始化完成后，JVM就可以使用这个类了，通过创建实例、调用方法等操作。
5. 卸载（Unloading）：
当某个类不再有任何引用，即不可触及时，JVM会在垃圾回收的过程中卸载类，释放内存空间。

JVM类加载机制具有一个重要特性，即"懒加载"（Lazy Loading）机制，类加载操作通常是在第一次使用时才进行。另外，为了支持Java程序的运行时扩展，除了JVM提供的默认类加载器外，用户还可以自定义类加载器来扩展类加载的逻辑。

类加载器有以下几种类型：

   - 引导类加载器（Bootstrap ClassLoader）：用原生代码实现，加载Java的核心库。
   - 扩展类加载器（Extension ClassLoader）：加载Java的扩展库。
   - 系统类加载器（System ClassLoader）：它根据Java应用的类路径（CLASSPATH）来加载Java应用的class文件。

这整个过程是Java实现平台无关性的重要机制之一，允许编写一次，到处运行（write once, run anywhere）。
### (8).说说Java对象创建过程
Java对象的创建过程涉及了几个步骤，主要是在JVM中的堆内存中分配对象空间并初始化。这些步骤大致如下：

1. 类加载检查：
在对象实例化前，JVM必须检查指定类的类型信息是否已被加载、链接和初始化过。通常情况下，这一步骤是在类加载过程中完成的，加载阶段由类加载器执行，确保加载的类的信息是JVM所认可的。
2. 分配内存：
确定类已被加载后，JVM会为新对象分配内存。对象的内存大小在类加载完成后即可完全确定，JVM为每个新对象分配的内存包括所有实例变量所需的内存和一些额外空间（如对象头和对齐填充）。
JVM堆内存可能是连续的（在一个指针的移动中完成），也可能是非连续的（在多个不连续的内存块中寻找足够大小的空间）。具体的分配规则取决于JVM使用的垃圾收集器算法。
3. 初始化零值：
内存分配后，JVM将所有成员变量设置为默认值。这个步骤确保了对象的实例变量不会返回不确定的状态。
4. 设置对象头：
JVM会在分配给对象的内存中写入数据，包括对象的类的类型信息、方法数据和垃圾收集相关的信息。这就是常说的“对象头”。
5. 执行<init>方法：
最后，JVM会调用构造函数。构造函数可能会调用其他构造函数，或者调用同类或父类的构造函数，这些都可能涉及到递归。构造函数完成的工作包括指定的初始化（例如变量赋值和逻辑），都会经过这个步骤。

综上，Java对象的创建是一个由类加载检查开始，涉及内存分配、成员默认初始化、对象头设置，最终执行构造方法初始化对象状态的过程。这个过程由JVM的堆内存管理和垃圾回收机制来支持和优化。
### (9).知道类的生命周期吗？
是的，类在Java中的生命周期涉及多个阶段，从加载开始直到被卸载结束。具体来说，类的生命周期包括以下阶段：

1. 加载（Loading）：
这是类生命周期的第一步，由类加载器负责从文件系统、网络或其他源将.class文件读入JVM内存。
2. 链接（Linking）：
加载之后，类会被链接到JVM中。链接分为验证、准备和解析三个阶段：
   - 验证（Verification）：确保被加载的类符合JVM规范，没有安全问题。
   - 准备（Preparation）：为类的静态变量分配内存，并将其初始化为默认值。
   - 解析（Resolution）：将类中的符号引用转换为直接引用。
3. 初始化（Initialization）：
一旦链接阶段结束，下一步是对类进行初始化，这包括执行静态代码块和静态字段的初始化赋值。
4. 使用（Using）：
当类被初始化后，就可以创建对象，执行方法等操作了。
5. 卸载（Unloading）：
在某些时候，当一个类不再被使用，并且没有任何对该类的实例的引用存在时，JVM会认为该类是一个可回收的对象，最终将其卸载。这通常发生在装载了该类的类加载器不再被引用的时候。

类加载器的生命周期：
JVM中类的生命周期紧密关联其类加载器的生命周期。因为类加载器可以是应用中的对象，也会被垃圾收集器回收。当类加载器被回收时，由该类加载器加载的类也会被卸载，前提
### (10).简述Java的对象结构
在Java中，每个对象的内存结构分为几个部分，主要包括对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。下面是对这些部分的简要说明：
对象头（Object Header）：
标记字段（Mark Word）：记录对象自身的运行时数据，如哈希码（HashCode）、垃圾收集信息、锁状态标志、线程持有的锁等。
类型指针（Class Metadata Address）：指向类元数据的指针，确定该对象是哪个类的实例。
在某些情况下，对象头可能还包括数组长度信息，如果对象是一个数组类型的话。
实例数据（Instance Data）：
对象真正存储的有效信息，也就是对象中的字段信息，包括该对象从父类继承的字段。
实例数据的排列顺序与字段在类中定义的顺序相关，并且可能会因为JVM的具体实现和字段的访问频率进行重排。
字段数据类型也会影响存儲结构，比如不同数据类型的字段可能会在内存中聚集在一起。
对齐填充（Padding）：
由于JVM要求对象的起始地址必须是8字节的整数倍（这个数值可能根据平台和JVM的实现有所不同），实例数据之后可能会有0到7字节的对齐填充，以确保对象的总大小为8字节的倍数。
这样的对象结构优化了内存的使用，并且简化了对象属性的访问过程。内存的对齐也有助于提高性能，因为这可能使得对象的访问更适宜当代计算机的缓存系统。
### (11).如何判断对象可以被回收？
在Java中，对象的垃圾回收主要依赖于可达性分析（Reachability Analysis）算法来判断对象是否可以被回收。以下是判断对象是否可以被回收的几个标准：
引用计数（Reference Counting）：
这是一种简单的垃圾回收算法，对象有一个与之关联的引用计数器。每当有一个引用连接到对象时，引用计数加一；当引用失效时，计数减一。任何时刻计数为零的对象便可被回收。
但是，在Java中，主要的垃圾回收器并不是基于引用计数器，因为它无法解决对象相互循环引用的问题。
可达性分析算法（Reachability Analysis）：
Java使用的是这种算法。它的基本思路是通过一系列的称为“根”（GC Roots）的对象作为起始点，从这些节点开始向下搜索，搜索所经过的路径称为“引用链”（Reference Chain）。
如果一个对象到所有的GC Roots都没有任何引用链相连（即从GC Roots到这个对象不可达），则证明此对象是不可用的。
GC Roots包括：
被栈中的局部变量所引用的对象（栈帧中的局部变量表）。
被方法区中的静态属性引用的对象。
被方法区中的常量引用的对象。
被本地方法栈中JNI（Java Native Interface）引用的对象。
其他判断回收的条件：
finalize：当对象无法到达时，垃圾收集器将调用其finalize()方法，此时对象可能被存活（如果在finalize()中该对象被引用），否则将被回收。
软引用（SoftReference）：当内存不足时，这类引用指向的对象可能被回收。
弱引用（WeakReference）：只要垃圾回收器发现了弱引用，不管当前内存空间足够与否，都会回收对象。
虚引用（PhantomReference）：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。
垃圾回收不可预知地发生，因此无法确切知道什么时候具体的对象会被回收。只能知道在进行可达性分析后，未被GC Roots引用的对象，被标记为可回收的状态。
### (12).JVM的永久代中会发生垃圾回收么？
在HotSpot JVM中，传统意义上的永久代（Permanent Generation，简称PermGen）是Java 8以前版本中存储已被加载类的信息、常量池、静态变量和即时编译器编译后的代码等的区域。由于这些类型的数据通常在应用程序的生命周期中很少进行修改，因此，在永久代中垃圾回收的频率会比年轻代和老年代要低很多。但这并不意味着永久代中不会发生垃圾回收。
确实，在永久代中可以发生垃圾回收，特别是以下几种情况：
卸载类：当类的ClassLoader被回收，该ClassLoader加载的类也会被卸载，前提是该类没有任何活跃的引用存在。
常量池整理：字符串常量池中的字符串可能会被清理，尤其是那些没有任何引用的字符串。
即时编译的代码回收：如果某段即时编译的代码长时间未被使用，或者系统处于做优化的需要，这段代码可能被视为可回收资源。
然而，从Java 8开始，永久代被元空间（Metaspace）所取代。元空间使用本地内存来存储类的元数据，其默认大小只受本地内存限制。在元空间中，与永久代相似，垃圾回收的行为主要包括类的卸载和废弃的即时编译代码的回收。由于元空间与直接内存相似，因此其大小不再由Java堆的大小直接限制，避免了永久代过小导致的OutOfMemoryError。不过，如果不加限制的话，元空间过大也会消耗过多的系统内存。
### (13).你知道哪些垃圾收集算法
垃圾收集（Garbage Collection，简称GC）算法是自动内存管理的核心，旨在识别并且回收那些不再被应用程序使用的内存。不同的垃圾收集算法有不同的特性，并且适用于不同类型和负载的应用程序。目前，常见的垃圾收集算法包括：
1. 标记-清除（Mark-Sweep）算法：
   - 标记阶段：遍历所有的GC Roots，标记所有从这些根节点开始可达的对象。
   - 清除阶段：遍历堆内存，回收所有未被标记的对象所占用的空间。
2. 复制（Copying）算法：
   - 堆内存被划分为两个大小相等的区域。每次只使用其中一个区域。
   - 当这一区域的内存用完时，将还存活的对象复制到另一区域，然后清理掉原区域的所有对象。
3. 标记-压缩（Mark-Compact）算法：
   - 在标记阶段与标记-清除算法相同。
   - 压缩阶段将所有存活的对象压缩到堆内存的一端，这样可以减少内存碎片。
4. 分代收集（Generational Collection）算法：
   - 将堆内存划分为年轻代（Young Generation）、老年代（Old Generation）和永久代（PermGen，Java 8后被元空间Metaspace取代），针对不同代使用不同的GC策略。
通常在年轻代使用复制算法，老年代使用标记-清除或标记-压缩算法。
1. 增量收集（Incremental Collection）算法：
   - 为了避免GC时的停顿，该算法将GC过程分为多个小步骤，轮流执行应用程序与GC操作。
2. 并发标记清除（Concurrent Mark-Sweep，CMS）算法：
   - 在满足实时性要求的前提下，尽量减少应用程序的停顿时间。
   - 通过并发标记和并发清除阶段减少GC时的停顿。
3. G1（Garbage-First）收集器：
   - 将堆内存划分为一个个大小相等的独立区域（Region）。
   - 通过优先收集价值最大化的区域（即包含大量垃圾的区域）来优化GC的性能，并且具有较好的暂停时间控制。
4. ZGC（Z Garbage Collector）和Shenandoah：
   - 这两种垃圾收集器的目标是减少STW（Stop-The-World，停止所有工作线程）暂停的时间。
它们通过并发的对象标记
### (14).调优命令有哪些？
垃圾收集算法是垃圾收集器决定在何时以及如何执行内存回收任务的一套策略。不同的垃圾收集器使用不同的算法，主流的垃圾收集算法包括：
标记-清除（Mark-Sweep）：
标记阶段：遍历所有的可达对象，并在本地存储里标记它们。
清除阶段：遍历堆内存，回收所有未被标记的对象。
缺点是会产生内存碎片。
复制（Copying）：
将存活的对象从当前内存区域复制到另一个区域，同时清理掉旧空间中的所有对象。
优点是简单、高效，不会产生碎片，通常用于年轻代。
标记-整理（Mark-Compact）：
在标记过程之后，不直接回收垃圾，而是将所有存活的对象移动到内存的一端，然后清除边界以外的内存。
该算法结合了标记-清除和复制算法的优点。
分代收集（Generational Collection）：
将堆分为几个区域（通常是年轻代和老年代），不同代用不同的策略来回收。年轻代使用复制算法，老年代使用标记-清除或标记-整理算法。
增量收集（Incremental Collection）：
将垃圾收集的过程分为多个小步骤，交替执行应用程序代码和垃圾收集代码，以减少应用程序停顿的时间。
并发标记清除（Concurrent Mark Sweep, CMS）：
主要用于减少应用程序停顿的垃圾收集器，它允许垃圾收集线程与应用程序线程并发执行。
G1（Garbage-First）：
将堆划分为多个（通常是2048个）小块，并且跨代回收，优先回收垃圾最多的区块。
对于垃圾收集器的调优命令来说，以下是一些常用的JVM参数，可以通过适当调整这些参数来优化性能：
-Xms：设置堆的初始大小。
-Xmx：设置堆的最大大小。
-XX:NewSize：设置年轻代的大小。
-XX:MaxNewSize：设置年轻代的最大大小。
-XX:PermSize：设置持久代（PermGen）的初始大小（仅适用于Java 8之前的版本）。
-XX:MaxPermSize：设置持久代的最大大小（仅适用于Java 8之前的版本）。
-XX:MetaspaceSize：设置元空间的初始大小（Java 8及之后的版本）。
-XX:MaxMetaspaceSize：设置元空间的最大大小（Java 8及之后的版本）。
-XX:+UseG1GC：开启G1垃圾收集器。
-XX:+UseConcMarkSweepGC：开启CMS垃圾收集器。
-XX:+UseParallelGC：开启并行收集器。
-XX:+UseParallelOldGC：开启并行老年代收集器。
-XX:+PrintGCDetails：打印详细的GC日志。
-XX:+PrintGCDateStamps：在GC日志中包括时间戳。
-XX:+PrintTenuringDistribution：打印对象晋升到老年代的详细信息。
-XX:SurvivorRatio：设置年轻代中Eden区与Survivor区的比例。
-XX:MaxTenuringThreshold：设置对象在Survivor区中复制的次数上限。
这些参数可以用来调整垃圾收集器的行为以及堆内存布局，最终目标是在减少垃圾回收导致的停顿和提高性能之间达到平衡。具体的最佳参数设置取决于应用程序的行为和需求。
### (15).常见调优工具有哪些
Java虚拟机（JVM）调优是一个复杂的过程，需要借助多种工具来收集数据并进行分析。常见的JVM调优工具包括：
**JVisualVM：**
包含在JDK中的一个多合一故障处理工具，用于检查JVM中的本地和远程应用程序。它可以监控应用程序的CPU、内存使用情况，分析堆转储，查看内存使用的变化，并进行线程分析等。
**JConsole：**
同样是JDK自带的JVM监视和管理控制台，它可以用来监控JVM的性能和资源消耗，包括线程使用、JVM内存消耗、类加载和JVM内部的其他数据。
**Java Flight Recorder (JFR) & Java Mission Control (JMC)**：
一组用于收集和分析来自Java应用程序和JVM本身的详细运行时信息的工具。Java Mission Control与Java Flight Recorder一起使用，以提供对JVM性能和其他详细数据的深入分析。
**GC日志分析工具：**
用于分析和可视化垃圾收集日志数据，这类工具包括 GCViewer, GCEasy, HPJmeter 和 IBM Pattern Modeling and Analysis Tool for Java Garbage Collector (PMAT)。
**MAT (Memory Analyzer Tool)**：
Eclipse开发的内存分析工具，用于分析Java堆内存，查找内存泄漏以及查看内存消耗的对象。
**VisualGC：**
可视化工具，用于监控HotSpot JVM的垃圾收集器和类加载器指标。
**YourKit Java Profiler：**
一个全功能的商业性能分析工具，提供了强大的CPU和内存分析功能，包括内存泄漏检测，CPU和内存热点分析，以及广泛的监测和可扩展性。
**JProfiler：**
另一个商业JVM分析工具，具有丰富的监视和性能分析功能来帮助开发者
### (16).Minor GC与Full GC分别在什么时候发生？
Minor GC和Full GC是Java垃圾收集过程中的两种不同类型的垃圾收集事件，它们发生的时机不同，影响的区域也不同：
Minor GC发生在年轻代（Young Generation）的内存满时。在Java堆内存管理中，年轻代主要包括了Eden区和两个Survivor区（通常被称为S0和S1）。当应用程序创建新对象时，这些对象首先被分配到Eden区。当Eden区满了，就会触发一次Minor GC，此过程通常包括：
标记可达对象。
清除不可达对象，并将可达对象移动到一个Survivor区。
对象在Survivor区之间来回复制，每次复制时年龄增加，当达到一定年龄阈值后，移动到老年代。
Full GC涉及整个Java堆内存，包括年轻代、老年代（Old Generation）以及方法区（如果使用了永久代或元空间的话）。Full GC发生的情况包括但不限于：
老年代空间不足：年轻代中的对象年龄增长到一定程度会被晋升到老年代，如果老年代空间不足以容纳这些新晋升的对象时，便会触发Full GC。
方法区空间不足：当方法区（或元空间）填满时，也会触发Full GC来释放空间。
System.gc()被调用：System类的gc()方法被调用时，会建议JVM执行Full GC，但是具体是否执行取决于JVM的策略和垃圾收集器的实现。
JVM内部的GC策略：由于JVM的内部机制，有时即使老年代未满，也可能触发Full GC。例如，为大对象分配空间时，或者JVM在某些收集器上执行了内部的GC策略决定执行Full GC。
Minor GC通常频繁且速度较快，因为只是清理年轻代的内存。相反，Full GC比较少发生但是耗时长得多，因为需要检查整个堆内存，并且在Full GC期间，JVM中的几乎所有线程都会暂停，所以有时也称为"Stop-the-World"事件。
### (17).你知道哪些JVM性能调优参数？（简单版回答）
当然，以下是一些基本的JVM性能调优参数：
-Xmx: 设置JVM最大堆大小。
-Xms: 设置JVM起始堆大小。
-Xmn: 设定年轻代大小。
-XX:PermSize: 设置永久代（Java 8之前）的初始大小。
-XX:MaxPermSize: 设置永久代的最大大小（Java 8之前）。
-XX:MetaspaceSize: 设置元空间的初始大小（Java 8及以后）。
-XX:MaxMetaspaceSize: 设置元空间的最大大小（Java 8及以后）。
-XX:+UseG1GC: 开启G1垃圾收集器。
-XX:+UseConcMarkSweepGC: 使用CMS垃圾收集器。
-XX:+UseParallelGC: 开启并行垃圾收集器。
-XX:+UseParallelOldGC: 使用并行老年代垃圾收集器。
-XX:+PrintGCDetails: 打印GC详情日志。
-XX:+PrintGCDateStamps: 打印GC的时间戳。
-XX:SurvivorRatio: 设置Eden区与Survivor区的容量比例。
-XX:NewRatio: 设置年轻代（包括Eden和两个Survivor区）与老年代的比例。
-XX:MaxTenuringThreshold: 设置对象在年轻代的最大晋升年龄。
-XX:+UseStringDeduplication: 开启Java 8u20及以后版本的String去重节省空间的特性。
根据需求和具体情况选择和调整这些参数，以优化JVM性能。
### (18).对象一定分配在堆中吗？有没有了解逃逸分析技术？
在Java中，对象通常是分配在堆内存中的，这是因为堆内存是由JVM在运行时动态分配和回收的一块内存区域，用于存放Java程序中创建的对象实例。堆内存的对象可以被程序中的任何线程访问。
然而，并非所有的对象都一定分配在堆上。通过JVM的逃逸分析技术，可能会发生不将对象分配到堆上的情况。逃逸分析是一个编译时优化策略，它分析数据的动态作用域来判断对象的分配存储。如果一个对象在方法中被创建，并且它的引用没有逃逸出这个方法，这个对象就可能被分配在栈上，这种技术叫做栈上分配。
栈上分配有几个好处：
提高内存分配的效率，栈上分配速度远快于堆上分配。
减少垃圾收集器的负担，栈上的对象可以随着方法结束而自然消亡，不需要GC介入。
逃逸分析还可以用于其他优化，比如同步消除（如果锁对象没有逃逸，那么锁操作可以消除）和标量替换（把一个对象拆散分配到多个独立的局部变量中）。
要开启逃逸分析，可以使用JVM参数-XX:+DoEscapeAnalysis，同时它默认是开启的。这是一个高级优化特性，通常会伴随JIT编译器在运行时动态作出优化决策。
### (19).虚拟机为什么使用元空间替换了永久代？
JVM在Java 8中引入了元空间（Metaspace），以取代原来的永久代（PermGen，Permanent Generation）。这个变化是基于几个原因：
内存管理简化：永久代是一个固定大小的内存区域，必须在JVM启动时指定其大小。不仅如此，开发者还需要预测其应用所需的最大元数据量，以避免OOM（OutOfMemoryError）错误。元空间利用本地内存（即操作系统的内存），从而可以动态调整大小，简化了内存管理。
性能稳定：永久代的固定大小会在很多场景下引发问题。如果分配不足，会发生永久代快速填满导致的频繁Full GC，从而影响性能。通过使用本地内存，元空间可以根据应用需求自动扩展，减少了因永久代过小而频繁进行Full GC的情况，增强了性能稳定性。
垃圾收集的改进：早期版本的JVM在进行GC时需要同时考虑永久代和堆内存，增加了垃圾收集的复杂性。将类元数据放到本地内存的元空间，使得永久代不再需要垃圾收集，从而简化了垃圾收集器的工作。
避免内存泄漏：由于永久代的大小是固定的，一些随着应用运行逐渐加载的类会持续占用这部分区域。如果类加载器无法被垃圾收集，它加载的类和所占用的内存也不会被回收，从而可能导致内存泄露。有了元空间，只要类加载器没有引用，它加载的类以及类元数据都可以被垃圾收集器回收。
和操作系统的兼容性：使用元空间能够使JVM的内存管理更为自然地与操作系统的内存管理模型相集成，有助于JVM在不同平台上的移植和优化。
因此，使用元空间替换永久代是为了优化内存管理，减少Full GC的频率，以及提高JVM垃圾收集的效率和性能稳定性。
### (20).什么是Stop The World ?  什么是OopMap？什么是安全点？
**Stop The World（STW）**指的是垃圾收集器在执行垃圾收集(GC)时，会暂停应用程序中的所有线程。在这段时间内，除了垃圾收集线程之外，没有任何线程可以执行，以保证在内存回收过程中对象引用关系不发生变化，从而安全地进行垃圾回收。STW事件的发生是GC的一个阶段，这个阶段对于几乎所有的GC算法和JVM实现都是必需的，但是GC算法的设计目标之一就是尽可能缩短STW的时间。
OopMap（Object-Oriented Programming Map）是一种数据结构，它在JVM中用于记录对象内存布局中的哪些部分是引用（即，Object-Oriented Pointers，OOPs）。在进行垃圾收集时，GC需要知道栈和寄存器中哪些位置是引用，这样才能识别所有的活动对象。OopMap由JIT编译器在编译时刻生成，确保在垃圾收集时能够迅速准确地找到这些引用。
**安全点（Safepoint）**是程序执行中的特定位置，JVM只会在这些位置停顿所有线程来进行某些特定的操作，比如垃圾回收。安全点是应用程序执行路径上的一点，这个点上可以认为所有的内存都是一致的，各个线程的状态都可以被安全地检查和修改。线程不能随意停止，它必须到达一个安全点才能停止。这主要是因为在安全点外，OopMap信息可能不准确，故而不能安全地执行垃圾收集。安全点的通常位置包括方法返回、循环的迭代之后、以及方法调用之前。
### (21).说一下JVM 的主要组成部分及其作用？
JVM（Java虚拟机）是运行Java字节码的抽象机器。它主要包含以下几个组件，每个部分都有其特定功能：
类加载器（Class Loaders）：负责加载class文件，class文件在文件系统上或网络上都可以找到。类加载器在JVM中扮演着把类文件（编译后的Java代码）加载到内存中、并形成JVM可以利用的Java类型的角色。
运行时数据区（Runtime Data Areas）：当JVM启动时，它会创建一个运行时数据区，其中包括：
程序计数器（Program Counter Register）：每个线程都有一个程序计数器，是线程私有的，它记录了线程当前的执行地址。
Java栈（Java Stack）：也是线程私有的，它的生命周期和线程相同，用于存储方法的局部变量、操作数栈和方法调用。
本地方法栈（Native Method Stack）：专门用于处理本地方法的调用。
堆（Heap）：所有线程共享的内存区域，它存放对象实例和数组。
方法区（Method Area）：同样是线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量等数据。
执行引擎（Execution Engine）：用于执行类文件中的指令。在执行引擎中，虚拟机指令根据它们被调用的次数和它们自己的复杂性，可以被解释执行（直接执行字节码）、JIT编译执行（将热点代码编译成优化的机器码）或者通过AOT编译（Ahead-of-Time编译，将字节码静态编译为机器码）执行。
本地库接口（Native Interface）：JVM通过本地库接口与本地库通信。这是一个桥梁，为JVM提供扩展性，使其可以调用其他编程语言编写的库。
垃圾回收器（Garbage Collectors）：自动管理JAVA应用程序创建的对象生命周期的系统。收集器的工作是识别内存中的无用对象，并且回收这些对象占用的内存空间，以供新对象使用。
这些组成部分共同工作，确保了Java应用程序可以在不同平台上运行，而不需要对代码进行任何修改，体现了Java的"Write Once, Run Anywhere"（WORA）的理念。
### (22).什么是指针碰撞？
指针碰撞（Pointer Bumping）是Java内存管理中的一个概念。
在对Java堆进行内存分配时，有两种常见的方式：一种是指针碰撞，另一种是空闲列表。
指针碰撞（Pointer Bumping）：如果Java堆中内存是绝对连续的，且所有用过的内存都放在一边，剩余内存放在另一边，那么分配内存时只需要动态改变一个指针即可。这个过程就像两个指针向对方移动，当两个指针相遇时，就意味着没有剩余内存了，会引发内存溢出异常，这个过程称为指针碰撞。这种方式的前提是，内存区间中存储的对象必需要连续放置，不能出现空隙。
空闲列表（Free List）：如果Java堆中的内存并不是绝对连续的，那么我们无法使用指针碰撞进行内存分配。此时，通常会选用一种称为空闲列表的方式。空闲列表通过一个列表来记录那些存储空间是可以使用的，分配的时候从列表中拿取一块可以使用的空间。
在JVM中，Serial、ParNew等垃圾收集器在新生代采用的是复制算法，所以新生代内存分配采用的是指针碰撞方式，而CMS这种以Mark-Sweep算法为基础的垃圾收集器，会产生内存碎片，内存分配时需要使用空闲列表方式。
### (23).什么是空闲列表？
空闲列表（Free List）是内存管理中的一种技术，它用来跟踪堆内存或其他内存池中空闲的内存块。每个空闲内存块都会在空闲列表中有一个对应的条目，该条目记录了内存块的位置和大小等信息。这个列表使得内存管理器能够知道哪些内存区域是未被分配的，并且可以用来存放新的数据对象。
在空闲列表内存管理策略中，当系统请求分配内存时，内存管理器会遍历空闲列表，寻找一个足够大的内存块来满足这个请求。根据特定的算法（如首次适应、最佳适应、最差适应等），管理器可能选择列表中的第一个能够满足需求的块，或者是最适合需求大小的块。
空闲列表的内存分配优点在于它能够处理各种大小的内存请求，并且可以在内存碎片之间寻找合适的位置进行数据存放。不过，频繁的分配和回收可能会导致列表中的内存块大小和顺序非常零散（内存碎片化），可能需要额外的内存整理（碎片整理）过程来优化内存分配效率。
在Java虚拟机（JVM）中，某些垃圾收集器在老年代使用空闲列表来管理内存，因为老年代中对象的生命周期较长，不适合使用复制算法，而是更倾向于使用标记-清理或者标记-整理算法来进行垃圾回收，这种情况下空闲列表可以有效管理内存分配。
### (24).什么是TLAB？
TLAB（Thread-Local Allocation Buffer）是Java虚拟机（JVM）堆内存中的一个概念，主要用于提升对象分配的性能。它是每个线程私有的内存分配区域。
在没有TLAB的情况下，所有线程分配对象都在堆的共享区域上进行，这可能导致多个线程在分配内存时互相竞争同一块内存区域，从而需要进行同步操作，这个过程称为锁竞争，它会降低性能。
为了解决这个问题，JVM采用了TLAB。使用TLAB以后，每个线程都能在各自的TLAB上分配对象，几乎完全消除了锁竞争。每个线程的TLAB只有该线程可以访问，因此在大部分情况下，对象的分配可以不需要同步，提高了分配速度。
当一个线程的TLAB空间不足时，它会分配一个新的TLAB，而旧的TLAB如果有剩余空间的话，通常来说会被废弃掉，因为一块TLAB只属于一个线程使用，不跨线程共享。这种方法虽然可能会造成一些内存的浪费，但由于它显著提高了对象分配的速度，所以这种浪费通常是值得的。
总之，TLAB是JVM中针对对象内存分配优化的一个重要技术，通过为每个线程提供专用的内存区域，它减少了线程间的竞争，提高了对象分配的性能。
### (25).对象头具体都包含哪些内容？
在Java中，对象头(Object Header)是每个对象的内存中的一部分，它包含了对象自身的运行时数据，用于存储对象自身的管理信息，比如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等。对象头的具体内容可以分为两部分：Mark Word和Class Metadata Address。
Mark Word：这是对象头的首部分，它记录对象自身的运行时数据，比如：
哈希码：存储对象的HashCode，这个HashCode可能在调用hashCode()方法时被生成。
GC分代年龄：对象在GC中的年龄信息。
锁状态标志：对象的锁信息，标记对象是否被某个线程锁定。
线程持有的锁：指向获得该对象锁的线程。
偏向线程ID：偏向锁中的线程ID，记录哪个线程拥有了偏向锁。
偏向时间戳：偏向锁的时间戳。
Class Metadata Address：接着Mark Word之后的即是指向对象类型元数据的指针，包含了对象类的元信息，比如类的全限定名、父类信息、方法信息、变量信息等。
对象头的大小在32位和64位JVM上是不同的，且取决于JVM的实现以及运行时的状态，如是否开启压缩指针(-XX:+UseCompressedOops)等选项。例如，在32位JVM上，对象头通常是8字节的Mark Word加上4字节的类型指针；而在64位JVM上，在不使用压缩指针的情况下，对象头可能是一个64位的Mark Word加上一个64位的类型指针，总共16字节。如果启用了压缩指针，那么对象头的大小可能会减少。
对象头是Java内存管理和同步锁机制的关键组成部分，JVM通过这部分信息来实现对象管理和垃圾收集等功能。
### (26).你知道哪些JVM调优参数？
### (27).说一下 JVM 有哪些垃圾回收器？
截至我的最新知识更新，Java虚拟机（JVM）提供了多种垃圾回收器（Garbage Collector，GC），每种回收器都有自己特定的应用场景和优化目标。这些回收器的设计旨在平衡不同的回收效率和暂停时间。以下是一些常见的JVM垃圾回收器：
Serial GC：这是最简单的GC实现，使用单个线程进行垃圾回收。它适合于单核处理器的系统或者小型堆。它在进行垃圾回收时会触发STW（Stop-The-World）暂停，停止所有的应用线程。
Parallel GC（也称为Throughput Collector）：这种回收器使用多个回收线程来并行地执行年轻代的垃圾回收，适用于多核服务器。它主要关注于达到一个高吞吐量。
CMS（Concurrent Mark-Sweep）GC：CMS GC主要目的是减少垃圾收集时的停顿时间。它在Mark和Sweep阶段的大部分工作都和应用线程一起并发执行。
G1 GC（Garbage-First Collector）：G1是一个面向服务器的垃圾回收器，特别适用于有大堆内存的多核CPU。G1通过将堆分割成多个区域来优化短暂的STW暂停，从而提供了一致的暂停时间模型。
ZGC（Z Garbage Collector）：ZGC是一种可伸缩的低延迟垃圾回收器，旨在减少应用程序响应时间的停顿。ZGC几乎所有的垃圾收集工作都是并发执行的。
Epsilon GC：这是一个实验性的、无操作的垃圾回收器，被称为"No-Op"或"Blackhole"回收器。它基本上不执行任何垃圾回收，主要用于测试和性能分析。
Shenandoah GC：与G1类似，Shenandoah GC也是一种并发的垃圾回收器，它的目标是尽可能减少STW暂停的时间，即使是在处理大堆或是多核CPU时。
这些回收器可以通过JVM启动参数进行配置。选择适合的垃圾回收器需要根据应用程序的特点和目标性能指标来决定，比如延迟、吞吐量、堆内存大小等因素。随着Java版本的不断更新，可能还会出现新的垃圾回收器或对现有回收器的改进。
### (28).如何选择垃圾收集器？
选择合适的垃圾收集器需要考虑多个因素，包括应用程序的特点、性能目标、硬件环境、以及可接受的系统停顿时间（STW）等。以下是选择垃圾收集器时的一些指南：
应用类型和响应要求：
对于需要更低延迟的应用程序，如实时系统或者具有交互式负载的应用程序，可以考虑使用CMS、G1或ZGC等具有并发收集阶段的收集器。
对于批处理系统、科学计算等吞吐量优先的应用，Parallel GC可能是更好的选择。
堆大小：
对于小到中等大小的堆（一般小于4GB），可以使用Serial GC或Parallel GC。
对于大型堆（超过4GB），G1 GC、ZGC或Shenandoah GC更加适合，它们针对大堆优化，能够有效减少垃圾收集时的停顿。
硬件资源：
拥有多核心CPU和大量内存的服务器级硬件通常可以受益于G1 GC、ZGC和Shenandoah GC等并发和并行垃圾收集器，因为这些收集器能够更好地利用多核心系统。
性能指标：
如果应用程序的性能指标偏向于低停顿时间（即要求快速响应），那么CMS、G1、ZGC或Shenandoah GC可能是更好的选择。
如果性能指标偏向于高吞吐量，那么Parallel GC可能更适合。
STW暂停时间的接受度：
如果应用程序能够接受较长的STW暂停时间，Serial GC或Parallel GC可以被考虑。
如果要求尽可能短的STW暂停时间，那么应该考虑G1、ZGC或Shenandoah GC。
JVM的版本和性能更新：
根据所使用的JVM版本，可用的垃圾收集器选项可能有所不同。最新版本的JVM可能引入了新的垃圾收集器或对现有收集器进行了优化。
实验及监控：
应该在生产环境的压力测试中尝试不同的垃圾收集器配置，并监控其影响，包括GC的暂停时间，吞吐量以及内存占用情况。
在实际选择过程中，可以通过设置JVM启动参数（如-XX:+UseG1GC、-XX:+UseConcMarkSweepGC、-XX:+UseParallelGC等）来指定使用特定的垃圾收集器。最好的方法是对不同的垃圾收集器进行基准测试和实地测试，以确定最适合特定应用程序的垃圾收集器。
### (29).什么是类加载器？
类加载器（Class Loader）在Java中是负责加载类的对象。在Java虚拟机（JVM）中，类加载器通过将类的.class文件中的二进制数据读入到运行时的数据区，并将这些数据转换成Class类的一个实例，从而完成类的加载过程。每个类在JVM内部都会由一个Class实例来表示。
类加载器工作过程遵循以下三个主要步骤：
加载（Loading）：查找并导入Class文件。
链接（Linking）：
验证（Verification）：确保被加载类的正确性。
准备（Preparation）：为类的静态变量分配内存，并将其初始化为默认值。
解析（Resolution）：将类中的符号引用转换成直接引用。
初始化（Initialization）：对类的静态变量进行初始化为正确的初始值。
在JVM中，有几种不同类型的类加载器：
引导类加载器（Bootstrap Class Loader）：它是虚拟机的内置类加载器，负责加载JAVA_HOME\lib目录中的类库，或者被-Xbootclasspath参数指定的路径中的类库。引导类加载器是用原生代码编写的，并不继承自java.lang.ClassLoader。
扩展类加载器（Extension Class Loader）：它负责加载JAVA_HOME\lib\ext目录中或者由java.ext.dirs系统属性指定位置中的类库。
系统（应用）类加载器（System/Application Class Loader）：这是与平时接触最多的类加载器，它根据Java应用的类路径（CLASSPATH）来加载Java类。一般调用Class.forName()方法默认使用的就是系统类加载器。
类加载器之间存在层次关系，称为双亲委派模型（Parent Delegation Model）。在这个模型中，类加载器会先代理给其父加载器尝试加载类，这样做的好处是避免类的重复加载，以及保证了Java平台核心库的类的安全性。如果父加载器无法完成加载任务，子加载器才会尝试自己去加载。
双亲委派模型不仅能够提高加载效率，由于每个类都由它的加载器及其父加载器一起协作加载，这样也可以确保Java环境中类的唯一性，以及Java核心类库的安全。用户也可以自定义类加载器，通过继承ClassLoader类并重写其findClass方法来实现。
### (30).什么是 tomcat 类加载机制？
javaguide
### (1).介绍下 Java 内存区域(运行时数据区)
### (2).说一下Java对象的创建过程
### (3).对象的访问定位有哪两种方式?
### (4).简单聊聊 JVM 内存分配与回收
### (5).说一下堆内存中对象的分配的基本策略
### (6).如何判断对象是否死亡?(两种方法)
### (7).简单的介绍一下强引用,软引用,弱引用,虚引用
### (8).如何判断一个常量是废弃常量?
### (9).如何判断一个类是无用的类?
### (10).垃圾收集有哪些算法，各自的特点？
### (11).HotSpot为什么要分为新生代和老年代？
### (12).常见的垃圾回收器有那些?
pdai
### (1).对象在堆中的生命周期
### (2).对象的分配过程
### (3).GC垃圾回收简介
### (4).TLAB
### (5).逃逸分析
### (6).移除永久代的原因
### (7).
