# JVM

## 目录
[toc]

## 一、个人总结
![](/Res/images/JVM知识框架.png)
![](/Res/images/JVM知识框架2.png)
![](/Res/images/JVM知识框架3.png)

### 1.1.类加载机制
![](/Res/images/JVM类加载机制.png)
1. **类加载步骤**
   1. **加载（loading）**
- 在这个阶段，JVM会通过类的全限定名来获取定义此类的二进制字节流。
- 这个过程通常由类加载器来完成，它从文件系统、网络或其他源读取.class文件，并转化为一个java.lang.Class对象。
- 对于数组类型，没有对应的字节码文件，它是由JVM在运行期动态生成的。 
   
   3. **验证（Verification）**
- 确保加载的类符合JVM规范，没有安全问题。
- 验证阶段可以分为文件格式验证、元数据验证、字节码验证和符号引用验证。
- 这一步是为了确保加载进来的字节码是良好格式化的，并且不会伤害到JVM自身的安全。
   
   4. **准备（Preparation）**
- JVM为类变量分配内存并设置类变量的默认初始值。
- 这些变量使用的内存都在方法区中进行分配。
   
   5. **解析（Resolution）**
- JVM将常量池内的符号引用替换为直接引用的过程。
- 符号引用来自于类型、方法、属性等的引用。
- 解析阶段将这些引用转化为实际的内存地址。
  
   6. **初始化（Initialization）**
- JVM负责对类进行初始化，主要包括执行类构造器`<clinit>()`方法的过程。
- `<clinit>()`方法是由编译器自动为每个类收集类变量的赋值动作和静态代码块中的语句合并而成。
- 在准备阶段完成之后，JVM会执行`<clinit>()`方法。
2. **类加载器**
   1. **启动类加载器(Bootstrap Class Loader)**
- 它是虚拟机自带的类加载器，负责加载Java的核心库（如`rt.jar`, `resources.jar`, `charsets.jar`等）。
- 启动类加载器是不由Java语言编写的，通常被认为是虚拟机的一部分。
- 它主要加载位于`<JAVA_HOME>/lib`目录或者被`-Xbootclasspath`参数指定的路径中的类。

   2. **扩展类加载器(Extension Class Loader)**
- 也称为标准扩展类加载器。
- 它负责加载JRE的扩展目录`<JAVA_HOME>/lib/ext`或者由Java系统变量`java.ext.dirs`指定位置中的JAR包。
- 它是`java.security.SecureClassLoader`的子类。
   
   3. **应用程序类加载器(Application Class Loader)**
- 这是与`ClassLoader.getSystemClassLoader()`方法返回的类加载器相对应。
- 它负责加载环境变量`CLASSPATH`或者系统属性`java.class.path`指定路径下的类库。
- 这个类加载器是用户自定义加载器的默认父加载器。

   4. **自定义加载器(User-Defined Class Loader)**
- Java允许开发者通过继承java.lang.ClassLoader类的方式自定义类加载器。
- 开发者可以重写findClass()方法来实现自己的加载逻辑。

   5. **系统类加载器（System Class Loader）**
- 这个加载器是Application Class Loader的同义词，为了区分概念上的不同，在某些上下文中单独称呼。
1. **三个重要特性**  
   1. **双亲委派机制**
![](/Res/images/JVM类加载机制-双亲委派.png) 
- 类加载器之间的一种层次关系。当一个类加载器收到加载请求时，它首先会将这个请求委派给父类加载器，一直向上委派到顶层的启动类加载器，只有当父类加载器无法完成这个加载请求时，子类加载器才会尝试自己去加载。
   
   2. **缓存机制**
- 出于性能考虑，一旦类被加载进内存中，它会被缓存起来，后面再次使用时不需要重新加载。

   3. **独立性**
- 不同的类加载器可以加载相同名称（全限定名）的类，这些类彼此不会产生冲突，因为属于不同的命名空间。
### 1.2.JVM内存模型（运行时数据区）
![](/Res/images/JVM内存.png)
![](/Res/images/JVM内存2.png)
1. **线程私有**
   1. 程序计数器
   2. 虚拟机栈
   3. 本地方法栈
2. **线程共享**
   1. 堆
   2. 方法区
3. **直接内存**
### 1.3.执行引擎
1. **即时编译器**
2. **垃圾收集机制**
### 1.4.本地接口库
### 1.5.本地方法库
### 1.6.性能监控与调优

## 二、八股问题整理

### (1).简述一下JVM的内存模型
![](/Res/images/Java内存区域-JavaGuide.png)
JVM的内存模型定义了Java虚拟机在计算机内存中的运行方式，它涉及到JVM如何以及在哪里管理内存。主要包括以下几个运行时数据区域：
1. **程序计数器（Program Counter Register）**
每个线程都有自己的程序计数器，它存储当前线程执行的字节码的行号，或者对于Native方法的调用，计数器的值是Undefined。
2. **Java虚拟机栈（Java Virtual Machine Stacks）**
也是线程私有的，每个方法在执行的同时都会创建一个栈帧（Stack Frame），用于存储局部变量表、操作数栈、动态链接信息等。
3. **本地方法栈（Native Method Stack）**
类似于Java栈，但是为Native方法服务。它们不受Java语言规范的限制，具体实现依赖于虚拟机实现。
4. **堆（Heap）**
JVM内存的大部分区域，所有的线程共享。它用来存储对象实例以及数组。这是垃圾回收器管理的主要区域，也是Java内存管理的核心。
5. **方法区（Method Area）**
各个线程共享的内存区域，用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。
6. **运行时常量池（Runtime Constant Pool）**
属于方法区的一部分，它存储编译期生成的各种字面量和符号引用，是每个类及接口的常量池的运行时表示形式。
7. **直接内存（Direct Memory）**
不是虚拟机运行时数据区的一部分，但也经常被用于NIO操作。这部分内存是JVM以外的内存，直接向系统申请的内存区域。

JVM内存模型的设计使得Java程序能够在多线程环境下安全有效地执行。每个线程都拥有自己的栈和程序计数器等，保证了执行的独立性，而堆和方法区则是线程间共享的内存资源，用于存储全局的类信息与对象。垃圾回收机制主要作用于堆内存和方法区部分，负责回收不再使用的对象以及类信息，确保内存的有效利用。
### (2).说说堆和栈的区别

**from《12万字Java面经总结》：**
栈是运行时单位，代表着逻辑，内含基本数据类型和堆中对象引用，所在区域连续，没有碎片；堆是存储单位，代表着数据，可被多个栈共享（包括成员中基本数据类型、引用和引用对象），所在区域不连续，会有碎片。
1. **功能不同**
栈内存用来存储局部变量和方法调用，而堆内存用来存储Java中的对象。无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。
1. **共享性不同**
栈内存是线程私有的。 堆内存是所有线程共有的。
1. **异常错误不同**
如果栈内存或者堆内存不足都会抛出异常。 栈空间不足：`java.lang.StackOverFlowError`。 堆空间不足：`java.lang.OutOfMemoryError`。
1. **空间大小**
栈的空间大小远远小于堆的。
### (3).什么时候会触发FullGC
Full GC（Full Garbage Collection）是一种全局性的垃圾收集过程，涵盖了所有的Java堆内存区域，包括年轻代（包含Eden区和Survivor区）、老年代以及元空间（或方法区，在JVM的不同版本中有不同的名称）。环境中存在多种情况可能会触发Full GC：
老年代空间不足：如果老年代（Old Generation）空间不足以分配新的对象，就会触发Full GC。而且，一些大对象或长期存活的对象会直接在老年代分配，如果对象过大导致老年代无法满足分配需求，也会触发Full GC。
元空间或者方法区空间不足：元空间存放了Java的类信息、常量、静态变量等数据。当元空间不足以分配新的类的元信息时，将会触发Full GC。
显式调用：如果在代码中显式调用了System.gc()，那么JVM就可能执行一次Full GC。
初始化：Full GC也可能在Java虚拟机执行某些初始化工作时被执行。
JVM参数：某些JVM启动参数设置也会产生Full GC，例如：对使用Serial/ParNew + CMS这类收集器组合，CMS收集器在某些情况下会转为Full GC。
值得注意的是，频繁的Full GC行为会严重影响应用服务器的性能，因为在Full GC进行期间，所有的用户线程会暂停，其中包括响应用户请求的线程。因此，在设计和优化Java应用的时候，我们总是尽量减少Full GC的发生。
### (4).什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？
Java虚拟机（JVM）是一个执行Java字节码的抽象计算引擎。它并不与任何特定的硬件架构绑定，是一种规范，各个硬件和操作系统平台都可以实现自己的JVM。这意味着编写的Java代码被编译成一种与平台无关的字节码格式，这些字节码可以在任何实现了JVM的平台上执行，无需做任何额外的适配。

Java之所以被称为“平台无关的编程语言”，主要基于以下两点：
1. **字节码：**
    - Java程序首先被编译为字节码（.class文件），这种中间状态是平台无关的。字节码是一种介于源代码和机器代码之间的代码，需要JVM来解释执行。
2. **JVM的跨平台特性：**
    - JVM是Java程序的运行环境，它有诸多不同的实现版本，这些不同的JVM版本分别为不同的操作系统（如Windows、Linux、macOS）所使用。这样，只要有相应平台的JVM实现，编译后的Java程序就可以在这些平台上运行，而无需做任何修改。

这种设计抽象了底层硬件和操作系统的细节，使得Java程序能够达到高度的可移植性。开发者只需写一次代码，就可以在任何支持JVM的设备上运行，大大减少了开发和部署应用程序的复杂度。
### (5).Java内存结构
![](/Res/images/java内存结构.png)
### (6).说说对象分配规则
对象的分配规则主要涉及到Java垃圾回收机制和JVM的内存模型。在HotSpot JVM中，对象主要在堆（Heap）上分配内存，堆内存又分为几个区域：年轻代（Young Generation）、老年代（Old Generation）和元空间（Metaspace；在Java 8之前是永久代 PermGen）。对象分配的规则通常如下：

1. **对象优先在Eden分配**：大部分情况下，对象会首先在年轻代的Eden区域分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC（也称作Young GC）。
2. **大对象直接进入老年代**：所谓大对象指需要大量连续内存空间的Java对象，例如很长的字符串或者数组。大对象会直接分配到老年代中，以避免在年轻代Eden区及两个Survivor区之间发生大量的内存复制。
3. **长期存活的对象将进入老年代**：对象在年轻代中经历了一定次数的GC后，如果还没有被回收，那么会被移到老年代中，以此减少在年轻代GC时的对象复活率。对象晋升到老年代的阈值可以通过参数`-XX:MaxTenuringThreshold`来设置。
4. **动态对象年龄判定**：为了更好地适应不同程序的内存状况，HotSpot JVM虚拟机并不是永远要求对象的年龄必须达到`MaxTenuringThreshold`才能晋升到老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到`MaxTenuringThreshold`中要求的年龄。
5. **空间分配担保**：在发生Minor GC之前，虚拟机会检查老年代最大可用的连续空间是否大于年轻代所有对象总空间，如果这个条件成立，那么Minor GC是安全的。如果不成立，则虚拟机会查看`HandlePromotionFailure`值是否允许担保失败。如果允许，那么会尝试一次Minor GC，如果不允许，或者尝试了还是失败，那么会改为进行一次Full GC。

根据不同的JVM和垃圾回收算法，对象分配的具体细节可能会有所不同。例如，使用G1垃圾收集器的JVM会有不同的对象分配策略。这些规则的目的是为了更有效地管理堆内存并最小化垃圾收集的影响。
### (7).描述一下JVM加载class文件的原理机制？
### (8).说说Java对象创建过程
### (9).知道类的生命周期吗？
### (10).简述Java的对象结构
### (11).如何判断对象可以被回收？
### (12).JVM的永久代中会发生垃圾回收么？
### (13).你知道哪些垃圾收集算法
### (14).调优命令有哪些？
### (15).常见调优工具有哪些
### (16).Minor GC与Full GC分别在什么时候发生？
### (17).你知道哪些JVM性能调优参数？（简单版回答）
### (18).对象一定分配在堆中吗？有没有了解逃逸分析技术？
### (19).虚拟机为什么使用元空间替换了永久代？
### (20).什么是Stop The World ?  什么是OopMap？什么是安全点？
### (21).说一下JVM 的主要组成部分及其作用？
### (22).什么是指针碰撞？
### (23).什么是空闲列表？
### (24).什么是TLAB？
### (25).对象头具体都包含哪些内容？
### (26).你知道哪些JVM调优参数？
### (27).说一下 JVM 有哪些垃圾回收器？
### (28).如何选择垃圾收集器？
### (29).什么是类加载器？
### (30).什么是 tomcat 类加载机制？
javaguide
### (1).介绍下 Java 内存区域(运行时数据区)
### (2).说一下Java对象的创建过程
### (3).对象的访问定位有哪两种方式?
### (4).简单聊聊 JVM 内存分配与回收
### (5).说一下堆内存中对象的分配的基本策略
### (6).如何判断对象是否死亡?(两种方法)
### (7).简单的介绍一下强引用,软引用,弱引用,虚引用
### (8).如何判断一个常量是废弃常量?
### (9).如何判断一个类是无用的类?
### (10).垃圾收集有哪些算法，各自的特点？
### (11).HotSpot为什么要分为新生代和老年代？
### (12).常见的垃圾回收器有那些?
