# Redis

## 目录
[TOC]

## 一、个人总结
### 1.安装配置
> 极简版，详细参考优质博客 [Windows下Redis安装与配置教程](https://blog.csdn.net/B11050729/article/details/131185533?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171308794116800222829974%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171308794116800222829974&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~top_positive~default-1-131185533-null-null.nonecase&utm_term=redis%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEwindows&spm=1018.2226.3001.4450)
1. redis
   - 下载地址 [Redis for Windows 5.0.14.1](https://github.com/tporadowski/redis/releases)
   - 解压缩
   - 解压路径下`cmd`-->`redis-server`-->**启动redis服务**
   - 解压路径下`cmd`-->`redis-cli`-->**连接到redis服务**
2. redisInsight(可视化工具)
   - 下载地址 [redisInsight for windows](https://app.redislabs.com/#/rlec-downloads)

### 2.redis概述
1. **什么是redis**

Redis是一款**内存高速缓存数据库**。Redis全称为：Remote Dictionary Server（远程数据服务），使用C语言编写，Redis是一个**key-value存储系统**（键值存储系统），支持丰富的数据类型，如：String、list、set、zset、hash。

Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。

2. **为什么使用redis**

- 读写性能优异:Redis能读的速度是110000次/s,写的速度是81000次/s
- 数据类型丰富:Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。
- 原子性:Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。
- 丰富的特性:Redis支持发布订阅、持久化、事件机制、事务，以及高可用&可扩展（分片模式、哨兵、主从复制）


3. **redis为什么快**

- **内存存储**：Redis是一个基于内存的数据存储系统，所有的数据操作都是直接在内存中进行的，相对于传统的磁盘存储，内存的读写速度要快得多。
- **数据结构简单**：Redis支持的数据结构相对简单（如字符串、列表、集合等），这些数据结构的操作都非常高效。
- **单线程模型**：Redis采用单线程模型来处理客户端的请求，这样可以避免线程切换和竞争状态的开销，尽管是单线程，但由于大多数操作都是内存操作，其性能依旧非常高。
- **非阻塞I/O**：Redis使用了非阻塞的网络I/O模型，例如epoll作为I/O多路复用技术的一部分，这使得Redis可以高效地处理多个客户端的连接和请求。
- **优化的数据操作算法**：Redis针对其支持的数据结构和操作进行了高度优化，许多操作的时间复杂度都很低（例如O(1)或O(log n)）。
- **持久化策略**：尽管是基于内存的系统，Redis也提供了RDB和AOF两种持久化方式，这些持久化操作是以非阻塞方式执行的，不会影响主线程的性能。
- **支持管道化**（Pipelining）：客户端可以一次性发送多个命令到服务器，减少网络延迟，服务器处理完这些命令后，一次性将结果返回给客户端。
- **发布/订阅模式**：提供了有效的消息广播/订阅支持，通过有效的内存数据分发，加快了消息传递的速度。

总结：通过**内存操作、简单的数据结构、单线程模型，以及高效的网络I/O处理等技术，Redis能够提供极快的数据读写性能**，这使其成为在需要高速数据存取场景下的首选数据库。

4. **哪些场景下使用redis**
- **热点数据的缓存**

   缓存是Redis最常见的应用场景，之所有这么使用，主要是因为Redis读写性能优异。而且逐渐有取代memcached，成为首选服务端缓存的组件。而且，Redis内部是支持事务的，在使用时候能有效保证数据的一致性。

   作为缓存使用时，一般有两种方式保存数据：
   - 读取前，先去读Redis，如果没有数据，读取数据库，将数据拉入Redis。
   - 插入数据时，同时写入Redis。

   方案一：实施起来简单，但是有两个需要注意的地方：
   - 避免缓存击穿。（数据库没有就需要命中的数据，导致Redis一直没有数据，而一直命中数据库。）
   - 数据的实时性相对会差一点。

   方案二：数据实时性强，但是开发时不便于统一处理。当然，两种方式根据实际情况来适用。

   如：方案一适用于对于数据实时性要求不是特别高的场景。方案二适用于字典表、数据量不大的数据存储。

- **限时业务的运用**

   redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。

- **计数器相关问题**

   redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。

- **分布式锁**

   这个主要利用redis的setnx命令进行，setnx："set if not exists"就是如果不存在则成功设置缓存同时返回1，否则返回0 ，这个特性在很多后台中都有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过setnx设置一个lock， 如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。

   在分布式锁的场景中，主要用在比如秒杀系统等。

- **延时操作**

   比如在订单生产后我们占用了库存，10分钟后去检验用户是否真正购买，如果没有购买将该单据设置无效，同时还原库存。 由于redis自2.8.0之后版本提供Keyspace Notifications功能，允许客户订阅Pub/Sub频道，以便以某种方式接收影响Redis数据集的事件。 所以我们对于上面的需求就可以用以下解决方案，我们在订单生产时，设置一个key，同时设置10分钟后过期， 我们在后台实现一个监听器，监听key的实效，监听到key失效时将后续逻辑加上。当然我们**也可以利用rabbitmq、activemq等消息中间件的延迟队列服务**实现该需求。

- **排行榜相关问题**

   关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助redis的`SortedSet`进行热点数据的排序。比如点赞排行榜，**做一个SortedSet, 然后以用户的openid作为上面的username, 以用户的点赞数作为上面的score, 然后针对每个用户做一个hash, 通过zrangebyscore就可以按照点赞数获取排行榜，然后再根据username获取用户的hash信息**，这个当时在实际运用中性能体验也蛮不错的。

- **点赞、好友等相互关系的存储**
   
   Redis 利用集合的一些命令，比如求交集、并集、差集等。在微博应用中，每个用户关注的人存在一个集合中，就很容易实现求两个人的共同好友功能。 

- **简单队列**
   
   由于Redis有`list push`和`list pop`这样的命令，所以能够很方便的执行队列操作

### 3.redis常用命令

### 4.redis配置文件详解

### 5.redis数据结构

首先对redis来说，所有的key（键）都是字符串。我们在谈基础数据结构时，讨论的是存储值的数据类型，主要包括常见的5种数据类型，分别是：String、List、Set、Zset、Hash。
![](/Res/images/Redis-数据结构-五种基本数据类型.jpeg)
#### 5.1 redis五种基础数据类型
1. String

2. List

3. Set

4. Zset

5. Hash
#### 5.2 redis三种特殊数据类型
#### 5.3 stream(v5.0)
#### 5.4 对象机制
#### 5.5 底层数据结构

### 6.redis核心知识
#### 6.1 持久化
#### 6.2 订阅/发布
#### 6.3 事件机制
#### 6.4 事务

### 7.高可用&可拓展
#### 7.1 redis集群之如何配置主从复制模式
#### 7.2 redis集群之哨兵模式
#### 7.3 redis分片技术

### 8.redis应用实践
#### 8.1 redis在jedis中如何使用和操作
#### 8.2 springboot整合redis
#### 8.3 redis缓存问题
#### 8.4 性能调优

## 二、八股问题整理
### redis概述
#### (1).为什么要用缓存
使用缓存的目的就是**提升读写性能**。而实际业务场景下，更多的是为了提升读性能，带来更好的性能，**带来更高的并发量**。 Redis 的读写性能比 Mysql 好的多，我们就可以把 Mysql 中的热点数据缓存到 Redis 中，提升读取性能，同时也减轻了 Mysql 的读取压力。
#### (2).什么是redis
Redis是一款内存**高速缓存数据库**。Redis全称为：Remote Dictionary Server（远程数据服务），使用C语言编写，Redis是一个`key-value`存储系统（键值存储系统），支持丰富的数据类型，如：String、list、set、zset、hash。

Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。

#### (3).为什么使用redis
- 读写性能优异
- 数据类型丰富
- 原子性
- 多种特性，持久化、订阅、发布、事务、主从复制、哨兵、分片

#### (4).redis为什么快
1. **内存存储**：Redis是一个基于内存的数据存储系统，所有的数据操作都是直接在内存中进行的，相对于传统的磁盘存储，内存的读写速度要快得多。
2. **数据结构简单**：Redis支持的数据结构相对简单（如字符串、列表、集合等），这些数据结构的操作都非常高效。
3. **单线程模型**：Redis采用单线程模型来处理客户端的请求，这样可以避免线程切换和竞争状态的开销，尽管是单线程，但由于大多数操作都是内存操作，其性能依旧非常高。
4. **非阻塞I/O**：Redis使用了非阻塞的网络I/O模型，例如epoll作为I/O多路复用技术的一部分，这使得Redis可以高效地处理多个客户端的连接和请求。
5. **优化的数据操作算法**：Redis针对其支持的数据结构和操作进行了高度优化，许多操作的时间复杂度都很低（例如O(1)或O(log n)）。
6. **持久化策略**：尽管是基于内存的系统，Redis也提供了RDB和AOF两种持久化方式，这些持久化操作是以非阻塞方式执行的，不会影响主线程的性能。
7. **支持管道化**（Pipelining）：客户端可以一次性发送多个命令到服务器，减少网络延迟，服务器处理完这些命令后，一次性将结果返回给客户端。
8. **发布/订阅模式**：提供了有效的消息广播/订阅支持，通过有效的内存数据分发，加快了消息传递的速度。

综上所述，通过**内存操作、简单的数据结构、单线程模型，以及高效的网络I/O处理等技术，Redis能够提供极快的数据读写性能**，这使其成为在需要高速数据存取场景下的首选数据库。
#### (5).哪些场景下使用redis
1. **热点数据的缓存**

缓存是Redis最常见的应用场景，之所有这么使用，主要是因为Redis读写性能优异。而且逐渐有取代memcached，成为首选服务端缓存的组件。而且，Redis内部是支持事务的，在使用时候能有效保证数据的一致性。

作为缓存使用时，一般有两种方式保存数据：
- 读取前，先去读Redis，如果没有数据，读取数据库，将数据拉入Redis。
- 插入数据时，同时写入Redis。

方案一：实施起来简单，但是有两个需要注意的地方：
  - 避免缓存击穿。（数据库没有就需要命中的数据，导致Redis一直没有数据，而一直命中数据库。）
  - 数据的实时性相对会差一点。

方案二：数据实时性强，但是开发时不便于统一处理。当然，两种方式根据实际情况来适用。

如：方案一适用于对于数据实时性要求不是特别高的场景。方案二适用于字典表、数据量不大的数据存储。

2. **限时业务的运用**

redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。

3. **计数器相关问题**

redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。

4. **分布式锁**

这个主要利用redis的setnx命令进行，setnx："set if not exists"就是如果不存在则成功设置缓存同时返回1，否则返回0 ，这个特性在很多后台中都有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过setnx设置一个lock， 如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。

在分布式锁的场景中，主要用在比如秒杀系统等。

5. **延时操作**

比如在订单生产后我们占用了库存，10分钟后去检验用户是否真正购买，如果没有购买将该单据设置无效，同时还原库存。 由于redis自2.8.0之后版本提供Keyspace Notifications功能，允许客户订阅Pub/Sub频道，以便以某种方式接收影响Redis数据集的事件。 所以我们对于上面的需求就可以用以下解决方案，我们在订单生产时，设置一个key，同时设置10分钟后过期， 我们在后台实现一个监听器，监听key的实效，监听到key失效时将后续逻辑加上。当然我们**也可以利用rabbitmq、activemq等消息中间件的延迟队列服务**实现该需求。

6. **排行榜相关问题**

关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助redis的`SortedSet`进行热点数据的排序。比如点赞排行榜，**做一个SortedSet, 然后以用户的openid作为上面的username, 以用户的点赞数作为上面的score, 然后针对每个用户做一个hash, 通过zrangebyscore就可以按照点赞数获取排行榜，然后再根据username获取用户的hash信息**，这个当时在实际运用中性能体验也蛮不错的。

7. **点赞、好友等相互关系的存储**
   
Redis 利用集合的一些命令，比如求交集、并集、差集等。在微博应用中，每个用户关注的人存在一个集合中，就很容易实现求两个人的共同好友功能。 

8. **简单队列**
   
由于Redis有`list push`和`list pop`这样的命令，所以能够很方便的执行队列操作

### 3.redis常用命令

### 4.redis配置文件详解

### 5.redis数据结构
#### 5.1 redis五种基础数据类型
#### 5.2 redis三种特殊数据类型
#### 5.3 stream(v5.0)
#### 5.4 对象机制
#### 5.5 底层数据结构

### 6.redis核心知识
#### 6.1 持久化
#### 6.2 订阅/发布
#### 6.3 事件机制
#### 6.4 事务

### 7.高可用&可拓展
#### 7.1 redis集群之如何配置主从复制模式
#### 7.2 redis集群之哨兵模式
#### 7.3 redis分片技术

### 8.redis应用实践
#### 8.1 redis在jedis中如何使用和操作
#### 8.2 springboot整合redis
#### 8.3 redis缓存问题
#### 8.4 性能调优