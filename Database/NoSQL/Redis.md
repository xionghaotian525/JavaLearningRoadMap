# Redis

## 目录
[TOC]

## 一、个人总结
### 1.安装配置
> 极简版，详细参考优质博客 [Windows下Redis安装与配置教程](https://blog.csdn.net/B11050729/article/details/131185533?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171308794116800222829974%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171308794116800222829974&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~top_positive~default-1-131185533-null-null.nonecase&utm_term=redis%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEwindows&spm=1018.2226.3001.4450)
1. redis
   - 下载地址 [Redis for Windows 5.0.14.1](https://github.com/tporadowski/redis/releases)
   - 解压缩
   - 解压路径下`cmd`-->`redis-server`-->**启动redis服务**
   - 解压路径下`cmd`-->`redis-cli`-->**连接到redis服务**
2. redisInsight(可视化工具)
   - 下载地址 [redisInsight for windows](https://app.redislabs.com/#/rlec-downloads)

### 2.redis概述
1. **什么是redis**

Redis是一款**内存高速缓存数据库**。Redis全称为：Remote Dictionary Server（远程数据服务），使用C语言编写，Redis是一个**key-value存储系统**（键值存储系统），支持丰富的数据类型，如：String、list、set、zset、hash。

Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。

2. **为什么使用redis**

- 读写性能优异:Redis能读的速度是110000次/s,写的速度是81000次/s
- 数据类型丰富:Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。
- 原子性:Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。
- 丰富的特性:Redis支持发布订阅、持久化、事件机制、事务，以及高可用&可扩展（分片模式、哨兵、主从复制）


3. **redis为什么快**

- **内存存储**：Redis是一个基于内存的数据存储系统，所有的数据操作都是直接在内存中进行的，相对于传统的磁盘存储，内存的读写速度要快得多。
- **数据结构简单**：Redis支持的数据结构相对简单（如字符串、列表、集合等），这些数据结构的操作都非常高效。
- **单线程模型**：Redis采用单线程模型来处理客户端的请求，这样可以避免线程切换和竞争状态的开销，尽管是单线程，但由于大多数操作都是内存操作，其性能依旧非常高。
- **非阻塞I/O**：Redis使用了非阻塞的网络I/O模型，例如epoll作为I/O多路复用技术的一部分，这使得Redis可以高效地处理多个客户端的连接和请求。
- **优化的数据操作算法**：Redis针对其支持的数据结构和操作进行了高度优化，许多操作的时间复杂度都很低（例如O(1)或O(log n)）。
- **持久化策略**：尽管是基于内存的系统，Redis也提供了RDB和AOF两种持久化方式，这些持久化操作是以非阻塞方式执行的，不会影响主线程的性能。
- **支持管道化**（Pipelining）：客户端可以一次性发送多个命令到服务器，减少网络延迟，服务器处理完这些命令后，一次性将结果返回给客户端。
- **发布/订阅模式**：提供了有效的消息广播/订阅支持，通过有效的内存数据分发，加快了消息传递的速度。

总结：通过**内存操作、简单的数据结构、单线程模型，以及高效的网络I/O处理等技术，Redis能够提供极快的数据读写性能**，这使其成为在需要高速数据存取场景下的首选数据库。

4. **哪些场景下使用redis**
- **热点数据的缓存**

   缓存是Redis最常见的应用场景，之所有这么使用，主要是因为Redis读写性能优异。而且逐渐有取代memcached，成为首选服务端缓存的组件。而且，Redis内部是支持事务的，在使用时候能有效保证数据的一致性。

   作为缓存使用时，一般有两种方式保存数据：
   - 读取前，先去读Redis，如果没有数据，读取数据库，将数据拉入Redis。
   - 插入数据时，同时写入Redis。

   方案一：实施起来简单，但是有两个需要注意的地方：
   - 避免缓存击穿。（数据库没有就需要命中的数据，导致Redis一直没有数据，而一直命中数据库。）
   - 数据的实时性相对会差一点。

   方案二：数据实时性强，但是开发时不便于统一处理。当然，两种方式根据实际情况来适用。

   如：方案一适用于对于数据实时性要求不是特别高的场景。方案二适用于字典表、数据量不大的数据存储。

- **限时业务的运用**

   redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。

- **计数器相关问题**

   redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。

- **分布式锁**

   这个主要利用redis的setnx命令进行，setnx："set if not exists"就是如果不存在则成功设置缓存同时返回1，否则返回0 ，这个特性在很多后台中都有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过setnx设置一个lock， 如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。

   在分布式锁的场景中，主要用在比如秒杀系统等。

- **延时操作**

   比如在订单生产后我们占用了库存，10分钟后去检验用户是否真正购买，如果没有购买将该单据设置无效，同时还原库存。 由于redis自2.8.0之后版本提供Keyspace Notifications功能，允许客户订阅Pub/Sub频道，以便以某种方式接收影响Redis数据集的事件。 所以我们对于上面的需求就可以用以下解决方案，我们在订单生产时，设置一个key，同时设置10分钟后过期， 我们在后台实现一个监听器，监听key的实效，监听到key失效时将后续逻辑加上。当然我们**也可以利用rabbitmq、activemq等消息中间件的延迟队列服务**实现该需求。

- **排行榜相关问题**

   关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助redis的`SortedSet`进行热点数据的排序。比如点赞排行榜，**做一个SortedSet, 然后以用户的openid作为上面的username, 以用户的点赞数作为上面的score, 然后针对每个用户做一个hash, 通过zrangebyscore就可以按照点赞数获取排行榜，然后再根据username获取用户的hash信息**，这个当时在实际运用中性能体验也蛮不错的。

- **点赞、好友等相互关系的存储**
   
   Redis 利用集合的一些命令，比如求交集、并集、差集等。在微博应用中，每个用户关注的人存在一个集合中，就很容易实现求两个人的共同好友功能。 

- **简单队列**
   
   由于Redis有`list push`和`list pop`这样的命令，所以能够很方便的执行队列操作

### 3.redis常用命令

1. 键值相关命令：
- `KEYS pattern`: 查找所有符合给定模式的键。
- `EXISTS key`: 检查给定键是否存在。
- `DEL key`: 删除给定的一个或多个键。
- `EXPIRE key seconds`: 设置键的过期时间。
- `TTL key`: 获取键的剩余生存时间。
- `TYPE key`: 获取键对应值的类型。
2. 字符串(**String**)相关命令:
- `SET key value`：设置存储在给定键中的值。
- `GET key`：获取指定键的值。
- `INCR key`：将键的整数值增加一。
- `INCRBY key amount`: 将键的整数值加amount。
- `DECR key`：将键的整数值减少一。
- `MSET key1 value1 [key2 value2 ...]`：同时设置一个或多个键值对。
- `MGET key1 key2 ...`: 获取多个键的值。
- `APPEND key value`: 将给定的值追加到原值的末尾。
3. 列表(**List**)相关命令:
- `LPUSH key value1 [value2]`：将一个或多个值插入到列表头部。
- `RPUSH key value1 [value2]`：将一个或多个值插入到列表尾部。
- `LPOP key`：移除并获取列表最左边的元素。
- `RPOP key`：移除并获取列表最右边的元素。
- `LRANGE key start stop`：获取列表指定范围内的元素。
- `LLEN key`: 获取列表的长度。
4. 集合(**Set**)相关命令:
- `SADD key member1 [member2]`：向集合添加一个或多个成员。
- `SREM key member1 [member2]`：移除集合中一个或多个成员。
- `SMEMBERS key`：获取集合中的所有成员。
- `SISMEMBER key member`：判断成员元素是否是集合的成员。
- `SINTER key1 [key2]`: 返回所有给定集合的交集。
- `SUNION key1 [key2]`: 返回所有给定集合的并集。
5. 有序集合(**Zset**, Sorted Set)相关命令:
- `ZADD key score1 member1 [score2 member2]`：向有序集合添加一个或多个成员，或者更新已存在成员的分数。
- `ZREM key member [member ...]`：移除有序集合中的一个或多个成员。
- `ZRANGE key start stop [WITHSCORES]`：按照索引范围返回有序集合指定区间内的成员。
- `ZREVRANGE key start stop [WITHSCORES]`：返回有序集合中指定区间内的成员，通过索引，分数从高到底。
- `ZSCORE key member`: 返回有序集中指定成员的分数。
6. 散列(**Hash**)相关命令:
- `HSET key field value`：给哈希表中的字段赋值。
- `HGET key field`：获取存储在哈希表中指定字段的值。
- `HGETALL key`：获取在哈希表中指定 key 的所有字段和值。
- `HMSET key field1 value1 [field2 value2 ...]`：同时将多个 field-value (字段-值)对设置到哈希表中。
- `HDEL key field1 [field2]`：删除一个或多个哈希表字段。
- `HEXISTS key field`: 检查哈希表中指定字段是否存在。
- `HKEYS key`: 获取哈希表中所有字段的名字。

7. HyperLogLog相关命令
- `PFADD`: 添加元素到HyperLogLog中。
- `PFCOUNT`: 返回HyperLogLog的近似基数，即估计的唯一元素数量。
- `PFMERGE`: 合并多个HyperLogLog为一个。
8. Gitmap相关命令
- `SETBIT`: 设置字符串指定偏移量的位(bit)值。
- `GETBIT`: 获取字符串指定偏移量的位(bit)值。
- `BITFIELD`: 对字符串的二进制位执行多个操作。
- `BITOP`: 对一个或多个Bitmap进行AND、OR、NOT、XOR操作。
- `BITCOUNT`: 计算字符串被设置为1的位的数量。
- `BITPOS`: 查找第一个设置为0或1的位的位置。
9.  geospatial相关命令
- `GEOADD`: 添加具有给定地理空间位置（经度、纬度）的元素。
- `GEODIST`: 返回两个给定位置之间的距离。
- `GEORADIUS`: 以给定的经纬度为中心，找出某个半径内的元素。
- `GEORADIUSBYMEMBER`: 以某个已存储的位置为中心，找出某个半径内的元素。
- `GEOHASH`: 返回一个或多个位置元素的Geohash字符串。
- `GEOPOS`: 返回一个或多个位置元素的经度和纬度。
10. stream

消息队列相关命令
- `XADD`: 用于向Stream中追加消息，如果Stream不存在，此命令会自动创建Stream。
- `XTRIM` 对流进行修剪，限制长度
- `XDEL` 删除消息
- `XLEN` 获取流包含的元素数量，即消息长度
- `XRANGE` 获取消息列表，会自动过滤已经删除的消息
- `XREVRANGE` 反向获取消息列表，ID 从大到小
- `XREAD` 以阻塞或非阻塞方式获取消息列表，用于读取Stream中的消息，可以指定从某个ID开始读取。

消费者组相关命令：

- `XGROUP CREATE` 创建消费者组
- `XREADGROUP GROUP` 读取消费者组中的消息
- `XACK` 将消息标记为"已处理"
- `XGROUP SETID` 为消费者组设置新的最后递送消息
- `IDXGROUP DELCONSUMER` 删除消费者
- `XGROUP DESTROY` 删除消费者组
- `XPENDING` 显示待处理消息的相关信息
- `XCLAIM` 转移消息的归属权
- `XINFO` 查看流和消费者组的相关信息；
- `XINFO GROUPS` 打印消费者组的信息；
- `XINFO STREAM` 打印流信息

### 4.redis配置文件详解

Redis可执行文件说明：
文件名|说明
---|---
redis-server|Redis服务器
redis-cli|Redis命令行客户端
redis-benchmark|Redis性能测试工具
redis-check-aof|Redis文件修复工具
redis-check-dump|Redis文件检查工具

redis.conf配置文件：
1. 网络设置:
`bind`: 指定Redis监听的网络接口（如127.0.0.1, 192.168.1.1等）。
`port`: 设置Redis监听的端口，默认是6379。
`timeout`: 设置客户端闲置多长时间后关闭连接。
`tcp-keepalive`: 设置TCP连接的keepalive参数。
2. 通用设置:
`daemonize`: 是否以守护进程运行。
`pidfile`: 当Redis以守护进程运行时，pidfile指定了文件写入PID的位置。
`loglevel` 和 `logfile`: 设置日志记录的详细级别（如debug、verbose、notice、warning）以及日志文件的位置。
`databases`: 设置数据库数量，默认通常为16。
3. 安全:
`requirepass`: 设置客户端连接到Redis服务器所需的密码。
`rename-command`: 重命名特定的命令，以提高安全性。
4. 持久化:
使用 `save` 参数设置自动快照的间隔。
`appendonly`: 是否开启AOF（Append Only File）持久化模式。
`appendfsync`: AOF文件写入磁盘的频率。
5. 性能和资源管理:
`maxmemory`: 设置最大内存使用限制，超出限制时Redis会根据maxmemory-policy策略来删除键。
`maxclients`: 设置同时连接的最大客户端数。
6. 集群:
`cluster-enabled`: 是否启用Redis集群模式。
`cluster-config-file`: 指定集群的配置文件。
`cluster-node-timeout`: 指定节点超时的毫秒数。
6. 哨兵(Sentinel)模式:
`sentinel monitor`: 当运行在哨兵模式下，监控指定名字的master。
`sentinel auth-pass`: 哨兵认证主服务器所需的密码。
7. 附加参数:
`include`: 允许包含其他配置文件，可用于模块化配置管理。

### 5.redis数据结构

![](/Res/images/Redis-数据结构.png)
#### 5.1 redis五种基础数据类型

首先对redis来说，所有的key（键）都是字符串。我们在谈基础数据结构时，讨论的是存储值的数据类型，主要包括常见的5种数据类型，分别是：**String**、**List**、**Set**、**Zset**、**Hash**。
![](/Res/images/Redis-数据结构-五种基本数据类型.jpeg)

**1. 字符串 (String):**

* 最基本的数据类型，可以是**字符串、整数或浮点数**，存储文本字符串，例如数字，邮件地址，图片，甚至是序列化后的对象。
* 常用命令: `SET`, `GET`, `INCR`, `DECR`, `MGET`等。
* 读写能力：对整个字符串或字符串的一部分进行操作；对整数或浮点数进行自增或自减操作；
* 使用场景: 缓存数据，计数器，分布式锁等。

**2. 列表 (List):**

* **字符串列表**，按插入顺序排序，链表上的每个节点都包含一个字符串。
* 常用命令: `LPUSH`, `RPUSH`, `LPOP`, `RPOP`, `LLEN`等。
* 读写能力：对链表的两端进行push和pop操作，读取单个或多个元素；根据值查找或删除元素；
* 使用场景: 消息队列，文章列表等需要顺序处理的数据。

**3. 集合 (Set):**

* **存储不重复且无序的字符串集合**。
* 常用命令: `SADD`, `SREM`, `SMEMBERS`, `SINTER`等。
* 读写能力：字符串的集合，包含基础的方法有看是否存在添加、获取、删除；还包含计算交集、并集、差集等
* 使用场景: 标签，社交关系，唯一性检查、点赞、点踩、收藏等。

**4. 有序集合 (Sorted Set):**

* **它可以保存唯一的字符串元素，并且每个元素都关联一个浮点数分数**，Redis根据这个分数将所有元素从小到大排序。
* 常用命令: `ZADD`, `ZREM`, `ZRANGE`, `ZSCORE`等。
* 读写能力：字符串成员与浮点数分数之间的有序映射；元素的排列顺序由分数的大小决定；包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素
* 使用场景: **排行榜**，**优先级队列**等需要排序的数据。

**5. 哈希 (Hash):**

* 键值对集合，**存储键值对的无序散列表**，类似于 Python 中的字典。
* 常用命令: `HSET`, `HGET`, `HGETALL`, `HDEL`等。
* 读写能力：包含方法有添加、获取、删除单个元素
* 使用场景: 适合存储对象，存储用户信息，商品信息等结构化数据。

#### 5.2 redis三种特殊数据类型
**1. HyperLogLogs**

* HyperLogLog是一种概率数据结构，用于估计一个集合中的唯一元素的数量（基数）。
* 常用命令：HyperLogLog主要相关的命令有`PFADD`、`PFCOUNT`和`PFMERGE`。
* 使用场景：HyperLogLog提供了不确切但在错误率可接受的情况下（标准误差0.81%）对基数进行近似计算的能力，这使得它在**需要统计大量数据并且对空间使用非常敏感的应用场景**下非常有用，如计数大量数据流中的唯一访问者数量。这个结构可以非常省内存的去统计各种计数，比如注册 IP 数、每日访问 IP 数、页面实时UV、在线用户数，共同好友数等。

**2. Bitmaps**

* Bitmaps并非Redis的一种独立数据类型，而是**字符串（String）数据类型的一种特殊使用方式**。在Bitmaps中，每个元素只占用一个二进制位(bit)，可以表示两种状态（0或1）。
* 常用命令：Bitmap提供了一套位级别的操作命令，如SETBIT、GETBIT、BITCOUNT和BITOP。
* 使用场景：它们非常**适用于需要大量布尔值的场景**，例如在线状态、特征标记、日活跃用户等，因为它们能够以极小的空间利用率进行存储和操作。

**3. geospatial**

* Redis的Geo数据类型基于**有序集合（Zset）**
* 常用命令：包括GEOADD、GEODIST、GEORADIUS和GEORADIUSBYMEMBER。
* 使用场景：它允许将**地理位置信息（经度和纬度）与名称关联起来**，并执行范围查询、半径查询和查找给定位置的周围元素等操作。例如，可以使用Geo数据类型来存储店铺的位置，并查询特定范围内的所有店铺，或计算两个地点之间的距离。

#### 5.3 stream(v5.0)
![](/Res/images/Redis-数据结构-stream结构2.png)
**1. 为什么会设计stream**

stream借鉴了Kafka的设计，是一个新的强大的支持多播的可持久化的**消息队列**。从字面上看是流类型，但其实从功能上看，是Redis对消息队列（MQ，Message Queue）的完善实现。

**2. stream应用场景**

* **消息队列**（Message Queuing）
   - 分布式任务队列：可以将Redis Streams作为后台作业或任务的队列，系统中的生产者将任务发布到Stream中，消费者从中读取并处理这些任务。
   - 应用解耦：在微服务架构中，使用Streams来传递消息，可以减少服务间的直接依赖，提高系统的可扩展性和可维护性。
* **事件驱动架构**（Event-driven Architecture）
  - 事件通知：在基于事件的系统中，可以使用Streams来发布和订阅事件，使得当事件发生时，相关的服务可以立即做出响应。
  - 实时数据处理：例如，实时分析用户行为、监控数据或物联网（IoT）设备的状态变化。
* **日志收集**（Log Aggregation）
将来自不同服务或应用的日志聚合到一个中心位置，方便实时监控和后续的日志分析处理。
* **流式数据分析**（Stream Analytics）
对实时产生的数据流（比如来自社交媒体、电商平台的交易数据）进行实时分析和处理，以便快速做出决策或洞察消费者行为等。
* **聊天应用和实时通信**（Chat Apps and Real-time Communication）
用于构建高性能、可扩展的聊天应用，使用Stream来传递消息和事件，实现实时通信。
* **时间序列数据**
收集和分析时间序列数据（例如金融市场数据、气象数据等），Redis Streams可以通过其消息ID来确保数据的时间顺序性。

Redis Streams特别适合处理业务场景足够简单，对于数据丢失不敏感，而且消息积压概率比较小的情况，(需要高吞吐量、低延迟和可靠性的应用场景？)。此外，通过将数据持久化和实现消费群组的概念，它还提供了一种有效的方式来平衡消息的生产和消费，保证了数据处理的可靠性和效率。

**3. stream结构**
![](/Res/images/Redis-数据结构-stream结构.png)
* `Consumer Group` ：消费组，使用 XGROUP CREATE 命令创建，一个消费组有多个消费者(Consumer), 这些消费者之间是竞争关系。
* `last_delivered_id` ：游标，每个消费组会有个游标 last_delivered_id，任意一个消费者读取了消息都会使游标 last_delivered_id 往前移动。
* `pending_ids` ：消费者(Consumer)的状态变量，作用是维护消费者的未确认的 id。 pending_ids 记录了当前已经被客户端读取的消息，但是还没有 ack (Acknowledge character：确认字符)。如果客户端没有ack，这个变量里面的消息ID会越来越多，一旦某个消息被ack，它就开始减少。这个pending_ids变量在Redis官方被称之为PEL，也就是Pending Entries List，这是一个很核心的数据结构，它用来确保客户端至少消费了消息一次，而不会在网络传输的中途丢失了没处理。

此外我们还需要理解两点：
* 消息ID: 消息ID的形式是timestampInMillis-sequence，例如1527846880572-5，它表示当前的消息在毫米时间戳1527846880572时产生，并且是该毫秒内产生的第5条消息。消息ID可以由服务器自动生成，也可以由客户端自己指定，但是形式必须是整数-整数，而且必须是后面加入的消息的ID要大于前面的消息ID。
* 消息内容: 消息内容就是键值对，形如hash结构的键值对，这没什么特别之处。

**4. 独立消费**

我们可以在不定义消费组的情况下进行Stream消息的独立消费，当Stream没有新消息时，甚至可以阻塞等待。Redis设计了一个单独的消费指令`xread`，可以将Stream当成普通的消息队列(list)来使用。使用xread时，我们可以完全忽略消费组(Consumer Group)的存在，**就好比Stream就是一个普通的列表(list)**。

**5. 消费组消费**
![](/Res/images/Redis-数据结构-stream-消费组消费.png)
* 创建消费组
Stream通过`xgroup create`指令创建消费组(Consumer Group)，需要传递起始消息ID参数用来初始化`last_delivered_id`变量。
* 消费组消费
Stream提供了`xreadgroup`指令可以进行消费组的组内消费，需要提供消费组名称、消费者名称和起始消息ID。它同xread一样，也可以阻塞等待新消息。读到新消息后，对应的消息ID就会进入消费者的PEL(正在处理的消息)结构里，客户端处理完毕后使用xack指令通知服务器，本条消息已经处理完毕，该消息ID就会从PEL中移除。
#### 5.4 对象机制
![](/Res/images/Redis-数据结构-RedisObject.png)
**1. 为什么会设计RedisObject**
- Redis 必须让每个键都带有类型信息, 使得程序可以检查键的类型, 并为它选择合适的处理方式

在redis的命令中，用于对键进行处理的命令占了很大一部分，而对于键所保存的值的类型（键的类型），键能执行的命令又各不相同。如： `LPUSH` 和 `LLEN` 只能用于列表键, 而 `SADD` 和 `SRANDMEMBER` 只能用于集合键, 等等; 另外一些命令, 比如 `DEL`、 `TTL` 和 `TYPE`, 可以用于任何类型的键；但是要正确实现这些命令, 必须为不同类型的键设置不同的处理方式: 比如说, 删除一个列表键和删除一个字符串键的操作过程就不太一样。

- 操作数据类型的命令除了要对键的类型进行检查之外, 还需要根据数据类型的不同编码进行多态处理

比如说， 集合类型就可以由字典和整数集合两种不同的数据结构实现， 但是， 当用户执行 `ZADD` 命令时， 他/她应该不必关心集合使用的是什么编码， 只要 Redis 能按照 `ZADD` 命令的指示， 将新元素添加到集合就可以了。

**2. redisObject数据结构**
```java
/*
 * Redis 对象
 */
typedef struct redisObject {

    // 类型
    unsigned type:4;

    // 编码方式
    unsigned encoding:4;

    // LRU - 24位, 记录最末一次访问时间（相对于lru_clock）; 或者 LFU（最少使用的数据：8位频率，16位访问时间）
    unsigned lru:LRU_BITS; // LRU_BITS: 24

    // 引用计数
    int refcount;

    // 指向底层数据结构实例
    void *ptr;

} robj;
```

![](/Res/images/Redis-数据结构-RedisObject数据结构.png)

- `type`记录了对象所保存的值的类型，它的值可能是以下常量中的一个：

```java
/*
* 对象类型
*/
#define OBJ_STRING 0 // 字符串
#define OBJ_LIST 1 // 列表
#define OBJ_SET 2 // 集合
#define OBJ_ZSET 3 // 有序集
#define OBJ_HASH 4 // 哈希表
```

- `encoding`记录了对象所保存的值的编码，它的值可能是以下常量中的一个：

```java
/*
* 对象编码
*/
#define OBJ_ENCODING_RAW 0     /* Raw representation */
#define OBJ_ENCODING_INT 1     /* Encoded as integer */
#define OBJ_ENCODING_HT 2      /* Encoded as hash table */
#define OBJ_ENCODING_ZIPMAP 3  /* 注意：版本2.6后不再使用. */
#define OBJ_ENCODING_LINKEDLIST 4 /* 注意：不再使用了，旧版本2.x中String的底层之一. */
#define OBJ_ENCODING_ZIPLIST 5 /* Encoded as ziplist */
#define OBJ_ENCODING_INTSET 6  /* Encoded as intset */
#define OBJ_ENCODING_SKIPLIST 7  /* Encoded as skiplist */
#define OBJ_ENCODING_EMBSTR 8  /* Embedded sds string encoding */
#define OBJ_ENCODING_QUICKLIST 9 /* Encoded as linked list of ziplists */
#define OBJ_ENCODING_STREAM 10 /* Encoded as a radix tree of listpacks */
```

- `ptr`是一个指针，指向实际保存值的数据结构，这个数据结构由`type`和`encoding`属性决定。举个例子， 如果一个redisObject 的`type` 属性为`OBJ_LIST` ， `encoding` 属性为 `OBJ_ENCODING_QUICKLIST` ，那么这个对象就是一个Redis 列表(List)，**它的值保存在一个QuickList的数据结构内，而ptr 指针就指向quicklist的对象**；

- `lru`属性: 记录了对象最后一次被命令程序访问的时间

**3. Redis执行处理数据类型命令的步骤**
- 根据给定的key，在数据库字典中查找和他相对应的redisObject，如果没找到，就返回NULL；
- 检查redisObject的type属性和执行命令所需的类型是否相符，如果不相符，返回类型错误；
- 根据redisObject的encoding属性所指定的编码，选择合适的操作函数来处理底层的数据结构；
- 返回数据结构的操作结果作为命令的返回值。

例：LPOP
![](/Res/images/Redis-数据结构-对象机制-处理数据类型命令步骤LPOP.png)
**4. 对象共享**

redis一般会把一些常见的值放到一个共享对象中，这样可使程序避免了重复分配的麻烦，也节约了一些CPU时间。

redis预分配的值对象：
- 小而常见的字符串，各种命令的返回值，比如成功时返回的OK，错误时返回的ERROR，命令入队事务时返回的QUEUE，等等
- 包括0 在内，小于`REDIS_SHARED_INTEGERS`的所有整数（`REDIS_SHARED_INTEGERS`的默认值是10000）

![](/Res/images/Redis-数据结构-RedisObject对象机制-对象共享.png)


**共享对象通常是跟指针结合使用的**，因为共享对象的目的是要让多个地方都能引用到同一个内存地址，而防止重复创建相同内容的对象。

但是，需要注意的是，对于 Redis 的字符串数据类型，引用共享对象还受到某些操作的限制。例如，一旦对一个共享的字符串进行修改，它就不再共享，因为字符串在 Redis 中是不可变的。这时，系统会创建一个新的对象以存储修改后的字符串，这是一种被称作写时复制（Copy-On-Write）的机制

**为什么redis不共享列表对象、哈希对象、集合对象、有序集合对象，只共享字符串对象？**

列表对象、哈希对象、集合对象、有序集合对象，本身可以包含字符串对象，复杂度较高。如果共享对象是保存字符串对象，那么验证操作的复杂度为O(1)如果共享对象是保存字符串值的字符串对象，那么验证操作的复杂度为O(N)如果共享对象是包含多个值的对象，其中值本身又是字符串对象，即其它对象中嵌套了字符串对象，比如列表对象、哈希对象，那么验证操作的复杂度将会是O(N的平方)如果对复杂度较高的对象创建共享对象，需要消耗很大的CPU，用这种消耗去换取内存空间，是不合适的

**5.   引用计数以及对象的销毁**

- 每个redisObject结构都带有一个`refcount`属性，指示这个对象被引用了多少次；
- 当新**创建**一个对象时，它的`refcount`属性被设置为1；
- 当对一个对象进行**共享**时，redis将这个对象的`refcount`加一；
- 当**使用完**一个对象后，或者**消除对一个对象的引用**之后，程序将对象的`refcount`减一；
- 当对象的`refcount`降至0 时，这个RedisObject结构，以及它引用的数据结构的内存都会被释放。

#### 5.5 底层数据结构
**1. 简单动态字符串** - sds

* 概述

Redis 中的 SDS（Simple Dynamic String，简单动态字符串）是 Redis 用于存储字符串值的底层实现，是对 C 语言传统字符串（以 null 结尾的字符数组）的改良，内部结构类似于 C 语言的字符数组，但**额外存储了字符串长度和分配空间大小**，避免了 C 字符串的缺陷。SDS **用于解决 C 字符串的一些限制和安全性问题**, 具有动态扩容的特点. 其实现位于`src/sds.h`与`src/sds.c`中。SDS 除了保存数据库中的字符串值以外，SDS 还可以作为缓冲区（buffer）：包括 AOF 模块中的AOF缓冲区以及客户端状态中的输入缓冲区。

* 结构
![](/Res/images/Redis-数据结构-底层数据结构-SDS.png)
![](/Res/images\Redis-数据结构-底层数据结构-SDS2.png)

* 为什么使用SDS

   - **长度灵活**： 
  SDS 在内存中的表示包含了字符串的长度信息，因此它可以包含任意长度的数据，包括空字符('\0')。这解决了 C 字符串无法存储空字符的问题。
  
  - **快速获取长度**：
  由于 `len` 属性的存在，我们获取 SDS 字符串的长度只需要读取 `len` 属性，时间复杂度为 O(1)。而对于 C 语言，获取字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。通过 `strlen key` 命令可以获取 key 的字符串长度。

  - **防止缓冲区溢出**：
   在 C 语言中使用 strcat 函数来进行两个字符串的拼接，**一旦没有分配足够长度的内存空间，就会造成缓冲区溢出**。而对于 SDS 数据类型，在进行字符修改的时候，会**首先根据记录的 len 属性检查内存空间是否满足需求, 如果不满足，会进行相应的空间扩展，然后在进行修改操作**，所以不会出现缓冲区溢出。

  - **减少修改字符串时的内存重新分配次数**：       
   C语言由于不记录字符串的长度，所以如果要修改字符串，必须要重新分配内存（**先释放再申请**），因为如果没有重新分配，字符串长度增大时会造成内存缓冲区溢出，字符串长度减小时会造成内存泄露。而对于SDS，由于`len`属性和`alloc`属性的存在，对于修改字符串SDS实现了空间预分配和惰性空间释放两种策略：   
      - **空间预分配**：对字符串进行空间扩展的时候，扩展的内存比实际需要的多，这样可以减少连续执行字符串增长操作所需的内存重分配次数。
        - 如果对 SDS 进行修改之后， SDS 的长度（也即是 len 属性的值）将小于 1 MB ， 那么程序分配和 len 属性同样大小的未使用空间， 这时 SDS len 属性的值将和 free 属性的值相同。 举个例子， 如果进行修改之后， SDS 的 len 将变成 13 字节， 那么程序也会分配 13 字节的未使用空间， SDS 的 buf 数组的实际长度将变成 13 + 13 + 1 = 27 字节（额外的一字节用于保存空字符）。
        - 如果对 SDS 进行修改之后， SDS 的长度将大于等于 1 MB ， 那么程序会分配 1 MB 的未使用空间。 举个例子， 如果进行修改之后， SDS 的 len 将变成 30 MB ， 那么程序会分配 1 MB 的未使用空间， SDS 的 buf 数组的实际长度将为 30 MB + 1 MB + 1 byte 。
      - **惰性空间释放**：对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 alloc 属性将这些字节的数量记录下来，等待后续使用。（当然SDS也提供了相应的API，当我们有需要时，也可以手动释放这些未使用的空间。）

  - **二进制安全**：SDS 可以存储任何二进制数据，包括图片、音频等非文本数据。这是因为 SDS 不依赖 null 字符来标识字符串的结束，而是以 `len` 属性表示的长度来判断字符串是否结束，因此数据中可以包含任意的二进制序列。
  - **兼容部分 C 字符串函数**：尽管 SDS 是对 C 字符串的扩展，但它的存储布局确保了在以 \0 结尾处的内存地址上的内容可以被视为一个正常的 C 字符串，这意味着可以在不需要复制字符串的前提下，利用 C 的一些标准库函数来操作 SDS。

**2. 压缩列表** - ZipList

- 概述
一种连续内存空间存储的顺序数据结构，每个元素可以是字符串或整数。优点:节省内存空间。适用于存储小规模的列表或有序集合。缺点:修改操作可能引发连锁更新，影响性能。使用场景: 在列表键元素较少或元素都是小整数时使用。

![](/Res/images/Redis-数据结构-底层数据结构-ziplist.png)

- ziplist结构

   - Header（头部）: 包含了ziplist的总字节长度、尾部（最后一个元素）的偏移量，以及ziplist中元素的数量。这些信息有助于快速地访问ziplist的基本属性和迅速找到ziplist的尾部。
   - Entry（项）: 每个项可以存储一个整数或者一个字符串。  
   - End（结束符）: 一个特定的字节（通常是0xFF），标记着ziplist的末尾，确保了ziplist结构的正确解析和遍历的终止。

- Entry结构

  - Previous Entry Length（前一项的长度）: 存储前一项的长度，使得ziplist可以被双向遍历。
  - Encoding（编码）: 指定了存储的值是整数还是字符串，以及使用了哪一种格式或长度。
  - Content（内容）: 实际存储的数据，可以是一个整数的二进制表示，或者是一个字符串的字节序列。

- 为什么ZipList特别省内存
   - ziplist节省内存是相对于普通的list来说的，如果是普通的数组，那么它每个元素占用的内存是一样的且取决于最大的那个元素（很明显它是需要预留空间的）；
   - 所以ziplist在设计时就很容易想到要尽量让每个元素按照实际的内容大小存储，**所以增加encoding字段**，**针对不同的encoding来细化存储大小**；
   - 这时候还需要解决的一个问题是遍历元素时如何定位下一个元素呢？在普通数组中每个元素定长，所以不需要考虑这个问题；但是ziplist中每个data占据的内存不一样，**所以为了解决遍历，需要增加记录上一个元素的length，所以增加了prelen字段**

- ziplist的缺点

  - **不预留内存空间**：ziplist 不预留额外的内存空间，在写操作时可能需要频繁进行内存分配和释放操作，影响性能。

  - **立即缩容**：在移除节点后，ziplist 立即缩容，可能导致频繁的内存分配和释放操作。

  - **链式扩容**：节点如果扩容，可能导致节点占用的内存增长，并且在超过一定字节后，可能会导致链式扩容。链式扩容的时间复杂度为 O(N)，虽然在大多数情况下概率较小，但在恶劣情况下会导致性能下降。

   综上所述，尽管 ziplist 能够有效地节省内存空间，但在写操作频繁、节点删除较多或节点扩容较大时，可能会出现性能问题。

**3. 快表** - QuickList

- 概述
QuickList是由多个 ziplist 组成的双向链表，每个 ziplist 存储一定数量的元素。优点:结合了 ziplist 和双向链表的优点，既节省空间，又提升了修改操作的性能。使用场景: 在列表键元素较多或包含较大元素时使用。
- quicklist结构
![](/Res/images/Redis-数据结构-底层数据结构-QuickList.png)

**4. 字典**/哈希表 - Dict

- 概述
Dict是一种基于哈希表的键值对数据结构，使用链地址法解决哈希冲突。优点:高效的查找、插入和删除操作，时间复杂度接近 O(1)。使用场景: 存储键值对数据，例如 Redis 的数据库和 Hash 类型。
- Dict结构
- 要点

**5. 整数集** - IntSet

- 概述
IntSet是一个存储整数值的集合，内部使用**有序、无重复**的数组保存数据。
优点:节省内存空间。
高效的查找、插入和删除操作。
使用场景: 在集合键只包含整数值且数量较少时使用。
- IntSet结构
- 整数集合的升级

**6. 跳表** - ZSkipList   

- 概述
ZSkipList是一种**有序**数据结构，支持平均 O(logN) 复杂度的查找、插入和删除操作。优点:高效的范围查询。使用场景: 存储有序集合数据，例如 Sorted Set 类型。
- ZSkipList结构
- 和平衡树和哈希表的对比

**1. 简单动态字符串 (SDS):**

* **用途：** 作为字符串值的底层实现，以及缓冲区。
* **优势：**
* **常数复杂度获取字符串长度:** SDS 保存了字符串长度信息，避免了每次获取长度都需要遍历字符串的开销。
* **防止缓冲区溢出:** SDS 在进行字符串修改操作时会先检查空间是否足够，避免了溢出问题。
* **空间预分配和惰性释放:** SDS 采用空间预分配策略，减少内存分配次数；惰性释放则避免了缩短字符串时立即释放内存，提高效率。
* **二进制安全:** SDS 可以存储任意二进制数据，而不仅仅是文本。

**2. 双端链表:**

* **用途：** 实现列表、发布/订阅、慢查询等功能。
* **优势：**
* **高效的节点插入和删除:** 双端链表可以在 O(1) 时间内进行头尾节点的插入和删除。
* **灵活的节点访问:** 可以方便地访问链表的任意节点。

**3. 字典:**

* **用途：** 实现数据库键空间、哈希键的底层实现。
* **优势：**
* **高效的键值对查找和插入:** 使用哈希表实现，查找、插入、删除操作的平均时间复杂度为 O(1)。
* **渐进式 rehash:** 在进行 rehash 操作时，不会阻塞 Redis 的正常运行。

**4. 跳跃表:**

* **用途：** 实现有序集合键，以及集群节点的内部排序。
* **优势：**
* **高效的范围查询:** 跳跃表能够在 O(log N) 时间内进行范围查询，比普通链表效率更高。
* **高效的节点插入和删除:** 跳跃表能够在 O(log N) 时间内进行节点的插入和删除，效率接近平衡树。

**5. 整数集合 (intset):**

* **用途：** 当集合只包含整数值且元素数量不多时，用作集合键的底层实现。
* **优势：**
* **节省内存:** intset 使用紧凑的整数数组存储数据，比哈希表更节省内存。
* **高效的升级:** 当 intset 不再满足条件时，会自动升级为哈希表。

**6. 压缩列表 (ziplist):**

* **用途：** 当列表只包含少量元素且元素长度较小时，用作列表键和哈希键的底层实现。
* **优势：**
* **节省内存:** ziplist 采用连续内存存储数据，比双端链表更节省内存。
* **节省内存:** ziplist 采用连续内存存储数据，比双端链表更节省内存。

### 6.redis核心知识
#### 6.1 持久化
#### 6.2 订阅/发布
#### 6.3 事件机制
#### 6.4 事务

### 7.高可用&可拓展
#### 7.1 redis集群之如何配置主从复制模式
#### 7.2 redis集群之哨兵模式
#### 7.3 redis分片技术

### 8.redis应用实践
#### 8.1 redis在jedis中如何使用和操作
#### 8.2 springboot整合redis
#### 8.3 redis缓存问题
#### 8.4 性能调优

## 二、八股问题整理
### redis概述
#### (1).为什么要用缓存
使用缓存的目的就是**提升读写性能**。而实际业务场景下，更多的是为了提升读性能，带来更好的性能，**带来更高的并发量**。 Redis 的读写性能比 Mysql 好的多，我们就可以把 Mysql 中的热点数据缓存到 Redis 中，提升读取性能，同时也减轻了 Mysql 的读取压力。
#### (2).什么是redis
Redis是一款内存**高速缓存数据库**。Redis全称为：Remote Dictionary Server（远程数据服务），使用C语言编写，Redis是一个`key-value`存储系统（键值存储系统），支持丰富的数据类型，如：String、list、set、zset、hash。

Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。

#### (3).为什么使用redis
- 读写性能优异
- 数据类型丰富
- 原子性
- 多种特性，持久化、订阅、发布、事务、主从复制、哨兵、分片

#### (4).redis为什么快
1. **内存存储**：Redis是一个基于内存的数据存储系统，所有的数据操作都是直接在内存中进行的，相对于传统的磁盘存储，内存的读写速度要快得多。
2. **数据结构简单**：Redis支持的数据结构相对简单（如字符串、列表、集合等），这些数据结构的操作都非常高效。
3. **单线程模型**：Redis采用单线程模型来处理客户端的请求，这样可以避免线程切换和竞争状态的开销，尽管是单线程，但由于大多数操作都是内存操作，其性能依旧非常高。
4. **非阻塞I/O**：Redis使用了非阻塞的网络I/O模型，例如epoll作为I/O多路复用技术的一部分，这使得Redis可以高效地处理多个客户端的连接和请求。
5. **优化的数据操作算法**：Redis针对其支持的数据结构和操作进行了高度优化，许多操作的时间复杂度都很低（例如O(1)或O(log n)）。
6. **持久化策略**：尽管是基于内存的系统，Redis也提供了RDB和AOF两种持久化方式，这些持久化操作是以非阻塞方式执行的，不会影响主线程的性能。
7. **支持管道化**（Pipelining）：客户端可以一次性发送多个命令到服务器，减少网络延迟，服务器处理完这些命令后，一次性将结果返回给客户端。
8. **发布/订阅模式**：提供了有效的消息广播/订阅支持，通过有效的内存数据分发，加快了消息传递的速度。

综上所述，通过**内存操作、简单的数据结构、单线程模型，以及高效的网络I/O处理等技术，Redis能够提供极快的数据读写性能**，这使其成为在需要高速数据存取场景下的首选数据库。
#### (5).哪些场景下使用redis
1. **热点数据的缓存**

缓存是Redis最常见的应用场景，之所有这么使用，主要是因为Redis读写性能优异。而且逐渐有取代memcached，成为首选服务端缓存的组件。而且，Redis内部是支持事务的，在使用时候能有效保证数据的一致性。

作为缓存使用时，一般有两种方式保存数据：
- 读取前，先去读Redis，如果没有数据，读取数据库，将数据拉入Redis。
- 插入数据时，同时写入Redis。

方案一：实施起来简单，但是有两个需要注意的地方：
  - 避免缓存击穿。（数据库没有就需要命中的数据，导致Redis一直没有数据，而一直命中数据库。）
  - 数据的实时性相对会差一点。

方案二：数据实时性强，但是开发时不便于统一处理。当然，两种方式根据实际情况来适用。

如：方案一适用于对于数据实时性要求不是特别高的场景。方案二适用于字典表、数据量不大的数据存储。

2. **限时业务的运用**

redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。

3. **计数器相关问题**

redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。

4. **分布式锁**

这个主要利用redis的setnx命令进行，setnx："set if not exists"就是如果不存在则成功设置缓存同时返回1，否则返回0 ，这个特性在很多后台中都有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过setnx设置一个lock， 如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。

在分布式锁的场景中，主要用在比如秒杀系统等。

5. **延时操作**

比如在订单生产后我们占用了库存，10分钟后去检验用户是否真正购买，如果没有购买将该单据设置无效，同时还原库存。 由于redis自2.8.0之后版本提供Keyspace Notifications功能，允许客户订阅Pub/Sub频道，以便以某种方式接收影响Redis数据集的事件。 所以我们对于上面的需求就可以用以下解决方案，我们在订单生产时，设置一个key，同时设置10分钟后过期， 我们在后台实现一个监听器，监听key的实效，监听到key失效时将后续逻辑加上。当然我们**也可以利用rabbitmq、activemq等消息中间件的延迟队列服务**实现该需求。

6. **排行榜相关问题**

关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助redis的`SortedSet`进行热点数据的排序。比如点赞排行榜，**做一个SortedSet, 然后以用户的openid作为上面的username, 以用户的点赞数作为上面的score, 然后针对每个用户做一个hash, 通过zrangebyscore就可以按照点赞数获取排行榜，然后再根据username获取用户的hash信息**，这个当时在实际运用中性能体验也蛮不错的。

7. **点赞、好友等相互关系的存储**
   
Redis 利用集合的一些命令，比如求交集、并集、差集等。在微博应用中，每个用户关注的人存在一个集合中，就很容易实现求两个人的共同好友功能。 

8. **简单队列**
   
由于Redis有`list push`和`list pop`这样的命令，所以能够很方便的执行队列操作

### 3.redis常用命令

### 4.redis配置文件详解

### 5.redis数据结构
#### 5.1 redis五种基础数据类型
#### 5.2 redis三种特殊数据类型
#### 5.3 stream(v5.0)
#### 5.4 对象机制
#### 5.5 底层数据结构

### 6.redis核心知识
#### 6.1 持久化
#### 6.2 订阅/发布
#### 6.3 事件机制
#### 6.4 事务

### 7.高可用&可拓展
#### 7.1 redis集群之如何配置主从复制模式
#### 7.2 redis集群之哨兵模式
#### 7.3 redis分片技术

### 8.redis应用实践
#### 8.1 redis在jedis中如何使用和操作
#### 8.2 springboot整合redis
#### 8.3 redis缓存问题
#### 8.4 性能调优