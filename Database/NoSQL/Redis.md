# Redis

## 目录
[TOC]

## 一、个人总结
### 1.安装配置
> 极简版，详细参考优质博客 [Windows下Redis安装与配置教程](https://blog.csdn.net/B11050729/article/details/131185533?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171308794116800222829974%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171308794116800222829974&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~top_positive~default-1-131185533-null-null.nonecase&utm_term=redis%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEwindows&spm=1018.2226.3001.4450)
1. redis
   - 下载地址 [Redis for Windows 5.0.14.1](https://github.com/tporadowski/redis/releases)
   - 解压缩
   - 解压路径下`cmd`-->`redis-server`-->**启动redis服务**
   - 解压路径下`cmd`-->`redis-cli`-->**连接到redis服务**
2. redisInsight(可视化工具)
   - 下载地址 [redisInsight for windows](https://app.redislabs.com/#/rlec-downloads)

### 2.redis概述
1. **什么是redis**

Redis是一款**内存高速缓存数据库**。Redis全称为：Remote Dictionary Server（远程数据服务），使用C语言编写，Redis是一个**key-value存储系统**（键值存储系统），支持丰富的数据类型，如：String、list、set、zset、hash。

Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。

2. **为什么使用redis**

- 读写性能优异:Redis能读的速度是110000次/s,写的速度是81000次/s
- 数据类型丰富:Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。
- 原子性:Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。
- 丰富的特性:Redis支持发布订阅、持久化、事件机制、事务，以及高可用&可扩展（分片模式、哨兵、主从复制）


3. **redis为什么快**

- **内存存储**：Redis是一个基于内存的数据存储系统，所有的数据操作都是直接在内存中进行的，相对于传统的磁盘存储，内存的读写速度要快得多。
- **数据结构简单**：Redis支持的数据结构相对简单（如字符串、列表、集合等），这些数据结构的操作都非常高效。
- **单线程模型**：Redis采用单线程模型来处理客户端的请求，这样可以避免线程切换和竞争状态的开销，尽管是单线程，但由于大多数操作都是内存操作，其性能依旧非常高。
- **非阻塞I/O**：Redis使用了非阻塞的网络I/O模型，例如epoll作为I/O多路复用技术的一部分，这使得Redis可以高效地处理多个客户端的连接和请求。
- **优化的数据操作算法**：Redis针对其支持的数据结构和操作进行了高度优化，许多操作的时间复杂度都很低（例如O(1)或O(log n)）。
- **持久化策略**：尽管是基于内存的系统，Redis也提供了RDB和AOF两种持久化方式，这些持久化操作是以非阻塞方式执行的，不会影响主线程的性能。
- **支持管道化**（Pipelining）：客户端可以一次性发送多个命令到服务器，减少网络延迟，服务器处理完这些命令后，一次性将结果返回给客户端。
- **发布/订阅模式**：提供了有效的消息广播/订阅支持，通过有效的内存数据分发，加快了消息传递的速度。

总结：通过**内存操作、简单的数据结构、单线程模型，以及高效的网络I/O处理等技术，Redis能够提供极快的数据读写性能**，这使其成为在需要高速数据存取场景下的首选数据库。

4. **哪些场景下使用redis**
- **热点数据的缓存**

   缓存是Redis最常见的应用场景，之所有这么使用，主要是因为Redis读写性能优异。而且逐渐有取代memcached，成为首选服务端缓存的组件。而且，Redis内部是支持事务的，在使用时候能有效保证数据的一致性。

   作为缓存使用时，一般有两种方式保存数据：
   - 读取前，先去读Redis，如果没有数据，读取数据库，将数据拉入Redis。
   - 插入数据时，同时写入Redis。

   方案一：实施起来简单，但是有两个需要注意的地方：
   - 避免缓存击穿。（数据库没有就需要命中的数据，导致Redis一直没有数据，而一直命中数据库。）
   - 数据的实时性相对会差一点。

   方案二：数据实时性强，但是开发时不便于统一处理。当然，两种方式根据实际情况来适用。

   如：方案一适用于对于数据实时性要求不是特别高的场景。方案二适用于字典表、数据量不大的数据存储。

- **限时业务的运用**

   redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。

- **计数器相关问题**

   redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。

- **分布式锁**

   这个主要利用redis的setnx命令进行，setnx："set if not exists"就是如果不存在则成功设置缓存同时返回1，否则返回0 ，这个特性在很多后台中都有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过setnx设置一个lock， 如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。

   在分布式锁的场景中，主要用在比如秒杀系统等。

- **延时操作**

   比如在订单生产后我们占用了库存，10分钟后去检验用户是否真正购买，如果没有购买将该单据设置无效，同时还原库存。 由于redis自2.8.0之后版本提供Keyspace Notifications功能，允许客户订阅Pub/Sub频道，以便以某种方式接收影响Redis数据集的事件。 所以我们对于上面的需求就可以用以下解决方案，我们在订单生产时，设置一个key，同时设置10分钟后过期， 我们在后台实现一个监听器，监听key的实效，监听到key失效时将后续逻辑加上。当然我们**也可以利用rabbitmq、activemq等消息中间件的延迟队列服务**实现该需求。

- **排行榜相关问题**

   关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助redis的`SortedSet`进行热点数据的排序。比如点赞排行榜，**做一个SortedSet, 然后以用户的openid作为上面的username, 以用户的点赞数作为上面的score, 然后针对每个用户做一个hash, 通过zrangebyscore就可以按照点赞数获取排行榜，然后再根据username获取用户的hash信息**，这个当时在实际运用中性能体验也蛮不错的。

- **点赞、好友等相互关系的存储**
   
   Redis 利用集合的一些命令，比如求交集、并集、差集等。在微博应用中，每个用户关注的人存在一个集合中，就很容易实现求两个人的共同好友功能。 

- **简单队列**
   
   由于Redis有`list push`和`list pop`这样的命令，所以能够很方便的执行队列操作

### 3.redis常用命令

1. 键值相关命令：
- `KEYS pattern`: 查找所有符合给定模式的键。
- `EXISTS key`: 检查给定键是否存在。
- `DEL key`: 删除给定的一个或多个键。
- `EXPIRE key seconds`: 设置键的过期时间。
- `TTL key`: 获取键的剩余生存时间。
- `TYPE key`: 获取键对应值的类型。
2. 字符串(**String**)相关命令:
- `SET key value`：设置存储在给定键中的值。
- `GET key`：获取指定键的值。
- `INCR key`：将键的整数值增加一。
- `INCRBY key amount`: 将键的整数值加amount。
- `DECR key`：将键的整数值减少一。
- `MSET key1 value1 [key2 value2 ...]`：同时设置一个或多个键值对。
- `MGET key1 key2 ...`: 获取多个键的值。
- `APPEND key value`: 将给定的值追加到原值的末尾。
3. 列表(**List**)相关命令:
- `LPUSH key value1 [value2]`：将一个或多个值插入到列表头部。
- `RPUSH key value1 [value2]`：将一个或多个值插入到列表尾部。
- `LPOP key`：移除并获取列表最左边的元素。
- `RPOP key`：移除并获取列表最右边的元素。
- `LRANGE key start stop`：获取列表指定范围内的元素。
- `LLEN key`: 获取列表的长度。
4. 集合(**Set**)相关命令:
- `SADD key member1 [member2]`：向集合添加一个或多个成员。
- `SREM key member1 [member2]`：移除集合中一个或多个成员。
- `SMEMBERS key`：获取集合中的所有成员。
- `SISMEMBER key member`：判断成员元素是否是集合的成员。
- `SINTER key1 [key2]`: 返回所有给定集合的交集。
- `SUNION key1 [key2]`: 返回所有给定集合的并集。
5. 有序集合(**Zset**, Sorted Set)相关命令:
- `ZADD key score1 member1 [score2 member2]`：向有序集合添加一个或多个成员，或者更新已存在成员的分数。
- `ZREM key member [member ...]`：移除有序集合中的一个或多个成员。
- `ZRANGE key start stop [WITHSCORES]`：按照索引范围返回有序集合指定区间内的成员。
- `ZREVRANGE key start stop [WITHSCORES]`：返回有序集合中指定区间内的成员，通过索引，分数从高到底。
- `ZSCORE key member`: 返回有序集中指定成员的分数。
6. 散列(**Hash**)相关命令:
- `HSET key field value`：给哈希表中的字段赋值。
- `HGET key field`：获取存储在哈希表中指定字段的值。
- `HGETALL key`：获取在哈希表中指定 key 的所有字段和值。
- `HMSET key field1 value1 [field2 value2 ...]`：同时将多个 field-value (字段-值)对设置到哈希表中。
- `HDEL key field1 [field2]`：删除一个或多个哈希表字段。
- `HEXISTS key field`: 检查哈希表中指定字段是否存在。
- `HKEYS key`: 获取哈希表中所有字段的名字。

7. HyperLogLog相关命令
- `PFADD`: 添加元素到HyperLogLog中。
- `PFCOUNT`: 返回HyperLogLog的近似基数，即估计的唯一元素数量。
- `PFMERGE`: 合并多个HyperLogLog为一个。
8. Gitmap相关命令
- `SETBIT`: 设置字符串指定偏移量的位(bit)值。
- `GETBIT`: 获取字符串指定偏移量的位(bit)值。
- `BITFIELD`: 对字符串的二进制位执行多个操作。
- `BITOP`: 对一个或多个Bitmap进行AND、OR、NOT、XOR操作。
- `BITCOUNT`: 计算字符串被设置为1的位的数量。
- `BITPOS`: 查找第一个设置为0或1的位的位置。
9.  geospatial相关命令
- `GEOADD`: 添加具有给定地理空间位置（经度、纬度）的元素。
- `GEODIST`: 返回两个给定位置之间的距离。
- `GEORADIUS`: 以给定的经纬度为中心，找出某个半径内的元素。
- `GEORADIUSBYMEMBER`: 以某个已存储的位置为中心，找出某个半径内的元素。
- `GEOHASH`: 返回一个或多个位置元素的Geohash字符串。
- `GEOPOS`: 返回一个或多个位置元素的经度和纬度。
10. stream

消息队列相关命令
- `XADD`: 用于向Stream中追加消息，如果Stream不存在，此命令会自动创建Stream。
- `XTRIM` 对流进行修剪，限制长度
- `XDEL` 删除消息
- `XLEN` 获取流包含的元素数量，即消息长度
- `XRANGE` 获取消息列表，会自动过滤已经删除的消息
- `XREVRANGE` 反向获取消息列表，ID 从大到小
- `XREAD` 以阻塞或非阻塞方式获取消息列表，用于读取Stream中的消息，可以指定从某个ID开始读取。

消费者组相关命令：

- `XGROUP CREATE` 创建消费者组
- `XREADGROUP GROUP` 读取消费者组中的消息
- `XACK` 将消息标记为"已处理"
- `XGROUP SETID` 为消费者组设置新的最后递送消息
- `IDXGROUP DELCONSUMER` 删除消费者
- `XGROUP DESTROY` 删除消费者组
- `XPENDING` 显示待处理消息的相关信息
- `XCLAIM` 转移消息的归属权
- `XINFO` 查看流和消费者组的相关信息；
- `XINFO GROUPS` 打印消费者组的信息；
- `XINFO STREAM` 打印流信息

### 4.redis配置文件详解

Redis可执行文件说明：
文件名|说明
---|---
redis-server|Redis服务器
redis-cli|Redis命令行客户端
redis-benchmark|Redis性能测试工具
redis-check-aof|Redis文件修复工具
redis-check-dump|Redis文件检查工具

redis.conf配置文件：
1. 网络设置:
`bind`: 指定Redis监听的网络接口（如127.0.0.1, 192.168.1.1等）。
`port`: 设置Redis监听的端口，默认是6379。
`timeout`: 设置客户端闲置多长时间后关闭连接。
`tcp-keepalive`: 设置TCP连接的keepalive参数。
2. 通用设置:
`daemonize`: 是否以守护进程运行。
`pidfile`: 当Redis以守护进程运行时，pidfile指定了文件写入PID的位置。
`loglevel` 和 `logfile`: 设置日志记录的详细级别（如debug、verbose、notice、warning）以及日志文件的位置。
`databases`: 设置数据库数量，默认通常为16。
3. 安全:
`requirepass`: 设置客户端连接到Redis服务器所需的密码。
`rename-command`: 重命名特定的命令，以提高安全性。
4. 持久化:
使用 `save` 参数设置自动快照的间隔。
`appendonly`: 是否开启AOF（Append Only File）持久化模式。
`appendfsync`: AOF文件写入磁盘的频率。
5. 性能和资源管理:
`maxmemory`: 设置最大内存使用限制，超出限制时Redis会根据maxmemory-policy策略来删除键。
`maxclients`: 设置同时连接的最大客户端数。
6. 集群:
`cluster-enabled`: 是否启用Redis集群模式。
`cluster-config-file`: 指定集群的配置文件。
`cluster-node-timeout`: 指定节点超时的毫秒数。
6. 哨兵(Sentinel)模式:
`sentinel monitor`: 当运行在哨兵模式下，监控指定名字的master。
`sentinel auth-pass`: 哨兵认证主服务器所需的密码。
7. 附加参数:
`include`: 允许包含其他配置文件，可用于模块化配置管理。

### 5.redis数据结构

![](/Res/images/Redis-数据结构.png)
#### 5.1 redis五种基础数据类型

首先对redis来说，所有的key（键）都是字符串。我们在谈基础数据结构时，讨论的是存储值的数据类型，主要包括常见的5种数据类型，分别是：**String**、**List**、**Set**、**Zset**、**Hash**。
![](/Res/images/Redis-数据结构-五种基本数据类型.jpeg)

**1. 字符串 (String):**

* 最基本的数据类型，可以是**字符串、整数或浮点数**，存储文本字符串，例如数字，邮件地址，图片，甚至是序列化后的对象。
* 常用命令: `SET`, `GET`, `INCR`, `DECR`, `MGET`等。
* 读写能力：对整个字符串或字符串的一部分进行操作；对整数或浮点数进行自增或自减操作；
* 使用场景: 缓存数据，计数器，分布式锁等。

**2. 列表 (List):**

* **字符串列表**，按插入顺序排序，链表上的每个节点都包含一个字符串。
* 常用命令: `LPUSH`, `RPUSH`, `LPOP`, `RPOP`, `LLEN`等。
* 读写能力：对链表的两端进行push和pop操作，读取单个或多个元素；根据值查找或删除元素；
* 使用场景: 消息队列，文章列表等需要顺序处理的数据。

**3. 集合 (Set):**

* **存储不重复且无序的字符串集合**。
* 常用命令: `SADD`, `SREM`, `SMEMBERS`, `SINTER`等。
* 读写能力：字符串的集合，包含基础的方法有看是否存在添加、获取、删除；还包含计算交集、并集、差集等
* 使用场景: 标签，社交关系，唯一性检查、点赞、点踩、收藏等。

**4. 有序集合 (Sorted Set):**

* **它可以保存唯一的字符串元素，并且每个元素都关联一个浮点数分数**，Redis根据这个分数将所有元素从小到大排序。
* 常用命令: `ZADD`, `ZREM`, `ZRANGE`, `ZSCORE`等。
* 读写能力：字符串成员与浮点数分数之间的有序映射；元素的排列顺序由分数的大小决定；包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素
* 使用场景: **排行榜**，**优先级队列**等需要排序的数据。

**5. 哈希 (Hash):**

* 键值对集合，**存储键值对的无序散列表**，类似于 Python 中的字典。
* 常用命令: `HSET`, `HGET`, `HGETALL`, `HDEL`等。
* 读写能力：包含方法有添加、获取、删除单个元素
* 使用场景: 适合存储对象，存储用户信息，商品信息等结构化数据。

#### 5.2 redis三种特殊数据类型
**1. HyperLogLogs**

* HyperLogLog是一种概率数据结构，用于估计一个集合中的唯一元素的数量（基数）。
* 常用命令：HyperLogLog主要相关的命令有`PFADD`、`PFCOUNT`和`PFMERGE`。
* 使用场景：HyperLogLog提供了不确切但在错误率可接受的情况下（标准误差0.81%）对基数进行近似计算的能力，这使得它在**需要统计大量数据并且对空间使用非常敏感的应用场景**下非常有用，如计数大量数据流中的唯一访问者数量。这个结构可以非常省内存的去统计各种计数，比如注册 IP 数、每日访问 IP 数、页面实时UV、在线用户数，共同好友数等。

**2. Bitmaps**

* Bitmaps并非Redis的一种独立数据类型，而是**字符串（String）数据类型的一种特殊使用方式**。在Bitmaps中，每个元素只占用一个二进制位(bit)，可以表示两种状态（0或1）。
* 常用命令：Bitmap提供了一套位级别的操作命令，如SETBIT、GETBIT、BITCOUNT和BITOP。
* 使用场景：它们非常**适用于需要大量布尔值的场景**，例如在线状态、特征标记、日活跃用户等，因为它们能够以极小的空间利用率进行存储和操作。

**3. geospatial**

* Redis的Geo数据类型基于**有序集合（Zset）**
* 常用命令：包括GEOADD、GEODIST、GEORADIUS和GEORADIUSBYMEMBER。
* 使用场景：它允许将**地理位置信息（经度和纬度）与名称关联起来**，并执行范围查询、半径查询和查找给定位置的周围元素等操作。例如，可以使用Geo数据类型来存储店铺的位置，并查询特定范围内的所有店铺，或计算两个地点之间的距离。

#### 5.3 stream(v5.0)
![](/Res/images/Redis-数据结构-stream结构2.png)
**1. 为什么会设计stream**

stream借鉴了Kafka的设计，是一个新的强大的支持多播的可持久化的**消息队列**。从字面上看是流类型，但其实从功能上看，是Redis对消息队列（MQ，Message Queue）的完善实现。

**2. stream应用场景**

* **消息队列**（Message Queuing）
   - 分布式任务队列：可以将Redis Streams作为后台作业或任务的队列，系统中的生产者将任务发布到Stream中，消费者从中读取并处理这些任务。
   - 应用解耦：在微服务架构中，使用Streams来传递消息，可以减少服务间的直接依赖，提高系统的可扩展性和可维护性。
* **事件驱动架构**（Event-driven Architecture）
  - 事件通知：在基于事件的系统中，可以使用Streams来发布和订阅事件，使得当事件发生时，相关的服务可以立即做出响应。
  - 实时数据处理：例如，实时分析用户行为、监控数据或物联网（IoT）设备的状态变化。
* **日志收集**（Log Aggregation）
将来自不同服务或应用的日志聚合到一个中心位置，方便实时监控和后续的日志分析处理。
* **流式数据分析**（Stream Analytics）
对实时产生的数据流（比如来自社交媒体、电商平台的交易数据）进行实时分析和处理，以便快速做出决策或洞察消费者行为等。
* **聊天应用和实时通信**（Chat Apps and Real-time Communication）
用于构建高性能、可扩展的聊天应用，使用Stream来传递消息和事件，实现实时通信。
* **时间序列数据**
收集和分析时间序列数据（例如金融市场数据、气象数据等），Redis Streams可以通过其消息ID来确保数据的时间顺序性。

Redis Streams特别适合处理业务场景足够简单，对于数据丢失不敏感，而且消息积压概率比较小的情况，(需要高吞吐量、低延迟和可靠性的应用场景？)。此外，通过将数据持久化和实现消费群组的概念，它还提供了一种有效的方式来平衡消息的生产和消费，保证了数据处理的可靠性和效率。

**3. stream结构**
![](/Res/images/Redis-数据结构-stream结构.png)
* `Consumer Group` ：消费组，使用 XGROUP CREATE 命令创建，一个消费组有多个消费者(Consumer), 这些消费者之间是竞争关系。
* `last_delivered_id` ：游标，每个消费组会有个游标 last_delivered_id，任意一个消费者读取了消息都会使游标 last_delivered_id 往前移动。
* `pending_ids` ：消费者(Consumer)的状态变量，作用是维护消费者的未确认的 id。 pending_ids 记录了当前已经被客户端读取的消息，但是还没有 ack (Acknowledge character：确认字符)。如果客户端没有ack，这个变量里面的消息ID会越来越多，一旦某个消息被ack，它就开始减少。这个pending_ids变量在Redis官方被称之为PEL，也就是Pending Entries List，这是一个很核心的数据结构，它用来确保客户端至少消费了消息一次，而不会在网络传输的中途丢失了没处理。

此外我们还需要理解两点：
* 消息ID: 消息ID的形式是timestampInMillis-sequence，例如1527846880572-5，它表示当前的消息在毫米时间戳1527846880572时产生，并且是该毫秒内产生的第5条消息。消息ID可以由服务器自动生成，也可以由客户端自己指定，但是形式必须是整数-整数，而且必须是后面加入的消息的ID要大于前面的消息ID。
* 消息内容: 消息内容就是键值对，形如hash结构的键值对，这没什么特别之处。

**4. 独立消费**
我们可以在不定义消费组的情况下进行Stream消息的独立消费，当Stream没有新消息时，甚至可以阻塞等待。Redis设计了一个单独的消费指令`xread`，可以将Stream当成普通的消息队列(list)来使用。使用xread时，我们可以完全忽略消费组(Consumer Group)的存在，**就好比Stream就是一个普通的列表(list)**。

**5. 消费组消费**
![](/Res/images/Redis-数据结构-stream-消费组消费.png)
* 创建消费组
Stream通过`xgroup create`指令创建消费组(Consumer Group)，需要传递起始消息ID参数用来初始化`last_delivered_id`变量。
* 消费组消费
Stream提供了`xreadgroup`指令可以进行消费组的组内消费，需要提供消费组名称、消费者名称和起始消息ID。它同xread一样，也可以阻塞等待新消息。读到新消息后，对应的消息ID就会进入消费者的PEL(正在处理的消息)结构里，客户端处理完毕后使用xack指令通知服务器，本条消息已经处理完毕，该消息ID就会从PEL中移除。
#### 5.4 对象机制
#### 5.5 底层数据结构

### 6.redis核心知识
#### 6.1 持久化
#### 6.2 订阅/发布
#### 6.3 事件机制
#### 6.4 事务

### 7.高可用&可拓展
#### 7.1 redis集群之如何配置主从复制模式
#### 7.2 redis集群之哨兵模式
#### 7.3 redis分片技术

### 8.redis应用实践
#### 8.1 redis在jedis中如何使用和操作
#### 8.2 springboot整合redis
#### 8.3 redis缓存问题
#### 8.4 性能调优

## 二、八股问题整理
### redis概述
#### (1).为什么要用缓存
使用缓存的目的就是**提升读写性能**。而实际业务场景下，更多的是为了提升读性能，带来更好的性能，**带来更高的并发量**。 Redis 的读写性能比 Mysql 好的多，我们就可以把 Mysql 中的热点数据缓存到 Redis 中，提升读取性能，同时也减轻了 Mysql 的读取压力。
#### (2).什么是redis
Redis是一款内存**高速缓存数据库**。Redis全称为：Remote Dictionary Server（远程数据服务），使用C语言编写，Redis是一个`key-value`存储系统（键值存储系统），支持丰富的数据类型，如：String、list、set、zset、hash。

Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。

#### (3).为什么使用redis
- 读写性能优异
- 数据类型丰富
- 原子性
- 多种特性，持久化、订阅、发布、事务、主从复制、哨兵、分片

#### (4).redis为什么快
1. **内存存储**：Redis是一个基于内存的数据存储系统，所有的数据操作都是直接在内存中进行的，相对于传统的磁盘存储，内存的读写速度要快得多。
2. **数据结构简单**：Redis支持的数据结构相对简单（如字符串、列表、集合等），这些数据结构的操作都非常高效。
3. **单线程模型**：Redis采用单线程模型来处理客户端的请求，这样可以避免线程切换和竞争状态的开销，尽管是单线程，但由于大多数操作都是内存操作，其性能依旧非常高。
4. **非阻塞I/O**：Redis使用了非阻塞的网络I/O模型，例如epoll作为I/O多路复用技术的一部分，这使得Redis可以高效地处理多个客户端的连接和请求。
5. **优化的数据操作算法**：Redis针对其支持的数据结构和操作进行了高度优化，许多操作的时间复杂度都很低（例如O(1)或O(log n)）。
6. **持久化策略**：尽管是基于内存的系统，Redis也提供了RDB和AOF两种持久化方式，这些持久化操作是以非阻塞方式执行的，不会影响主线程的性能。
7. **支持管道化**（Pipelining）：客户端可以一次性发送多个命令到服务器，减少网络延迟，服务器处理完这些命令后，一次性将结果返回给客户端。
8. **发布/订阅模式**：提供了有效的消息广播/订阅支持，通过有效的内存数据分发，加快了消息传递的速度。

综上所述，通过**内存操作、简单的数据结构、单线程模型，以及高效的网络I/O处理等技术，Redis能够提供极快的数据读写性能**，这使其成为在需要高速数据存取场景下的首选数据库。
#### (5).哪些场景下使用redis
1. **热点数据的缓存**

缓存是Redis最常见的应用场景，之所有这么使用，主要是因为Redis读写性能优异。而且逐渐有取代memcached，成为首选服务端缓存的组件。而且，Redis内部是支持事务的，在使用时候能有效保证数据的一致性。

作为缓存使用时，一般有两种方式保存数据：
- 读取前，先去读Redis，如果没有数据，读取数据库，将数据拉入Redis。
- 插入数据时，同时写入Redis。

方案一：实施起来简单，但是有两个需要注意的地方：
  - 避免缓存击穿。（数据库没有就需要命中的数据，导致Redis一直没有数据，而一直命中数据库。）
  - 数据的实时性相对会差一点。

方案二：数据实时性强，但是开发时不便于统一处理。当然，两种方式根据实际情况来适用。

如：方案一适用于对于数据实时性要求不是特别高的场景。方案二适用于字典表、数据量不大的数据存储。

2. **限时业务的运用**

redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。

3. **计数器相关问题**

redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。

4. **分布式锁**

这个主要利用redis的setnx命令进行，setnx："set if not exists"就是如果不存在则成功设置缓存同时返回1，否则返回0 ，这个特性在很多后台中都有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过setnx设置一个lock， 如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。

在分布式锁的场景中，主要用在比如秒杀系统等。

5. **延时操作**

比如在订单生产后我们占用了库存，10分钟后去检验用户是否真正购买，如果没有购买将该单据设置无效，同时还原库存。 由于redis自2.8.0之后版本提供Keyspace Notifications功能，允许客户订阅Pub/Sub频道，以便以某种方式接收影响Redis数据集的事件。 所以我们对于上面的需求就可以用以下解决方案，我们在订单生产时，设置一个key，同时设置10分钟后过期， 我们在后台实现一个监听器，监听key的实效，监听到key失效时将后续逻辑加上。当然我们**也可以利用rabbitmq、activemq等消息中间件的延迟队列服务**实现该需求。

6. **排行榜相关问题**

关系型数据库在排行榜方面查询速度普遍偏慢，所以可以借助redis的`SortedSet`进行热点数据的排序。比如点赞排行榜，**做一个SortedSet, 然后以用户的openid作为上面的username, 以用户的点赞数作为上面的score, 然后针对每个用户做一个hash, 通过zrangebyscore就可以按照点赞数获取排行榜，然后再根据username获取用户的hash信息**，这个当时在实际运用中性能体验也蛮不错的。

7. **点赞、好友等相互关系的存储**
   
Redis 利用集合的一些命令，比如求交集、并集、差集等。在微博应用中，每个用户关注的人存在一个集合中，就很容易实现求两个人的共同好友功能。 

8. **简单队列**
   
由于Redis有`list push`和`list pop`这样的命令，所以能够很方便的执行队列操作

### 3.redis常用命令

### 4.redis配置文件详解

### 5.redis数据结构
#### 5.1 redis五种基础数据类型
#### 5.2 redis三种特殊数据类型
#### 5.3 stream(v5.0)
#### 5.4 对象机制
#### 5.5 底层数据结构

### 6.redis核心知识
#### 6.1 持久化
#### 6.2 订阅/发布
#### 6.3 事件机制
#### 6.4 事务

### 7.高可用&可拓展
#### 7.1 redis集群之如何配置主从复制模式
#### 7.2 redis集群之哨兵模式
#### 7.3 redis分片技术

### 8.redis应用实践
#### 8.1 redis在jedis中如何使用和操作
#### 8.2 springboot整合redis
#### 8.3 redis缓存问题
#### 8.4 性能调优